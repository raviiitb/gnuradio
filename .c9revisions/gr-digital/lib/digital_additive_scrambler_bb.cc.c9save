{"ts":1360099866195,"silentsave":true,"restoring":false,"patch":[[{"diffs":[[1,"/* -*- c++ -*- */\n/*\n * Copyright 2008,2010,2012 Free Software Foundation, Inc.\n *\n * This file is part of GNU Radio\n *\n * GNU Radio is free software; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation; either version 3, or (at your option)\n * any later version.\n *\n * GNU Radio is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with GNU Radio; see the file COPYING.  If not, write to\n * the Free Software Foundation, Inc., 51 Franklin Street,\n * Boston, MA 02110-1301, USA.\n */\n\n#ifdef HAVE_CONFIG_H\n#include \"config.h\"\n#endif\n\n#include <digital_additive_scrambler_bb.h>\n#include <gr_io_signature.h>\n\ndigital_additive_scrambler_bb_sptr\ndigital_make_additive_scrambler_bb(int mask, int seed, int len, int count)\n{\n  return gnuradio::get_initial_sptr(new digital_additive_scrambler_bb\n\t\t\t\t    (mask, seed, len, count));\n}\n\ndigital_additive_scrambler_bb::digital_additive_scrambler_bb(int mask,\n\t\t\t\t\t\t\t     int seed,\n\t\t\t\t\t\t\t     int len,\n\t\t\t\t\t\t\t     int count)\n  : gr_sync_block(\"additive_scrambler_bb\",\n\t\t  gr_make_io_signature (1, 1, sizeof (unsigned char)),\n\t\t  gr_make_io_signature (1, 1, sizeof (unsigned char))),\n    d_lfsr(mask, seed, len),\n    d_count(count),\n    d_bits(0)\n{\n}\n\nint\ndigital_additive_scrambler_bb::work(int noutput_items,\n\t\t\t\t    gr_vector_const_void_star &input_items,\n\t\t\t\t    gr_vector_void_star &output_items)\n{\n  const unsigned char *in = (const unsigned char *) input_items[0];\n  unsigned char *out = (unsigned char *) output_items[0];\n\n  for (int i = 0; i < noutput_items; i++) {\n    out[i] = in[i]^d_lfsr.next_bit();\n    if (d_count > 0) {\n      if (++d_bits == d_count) {\n\td_lfsr.reset();\n\td_bits = 0;\n      }\n    }\n  }\n\n  return noutput_items;\n}\n"]],"start1":0,"start2":0,"length1":0,"length2":2029}]],"length":2029}
