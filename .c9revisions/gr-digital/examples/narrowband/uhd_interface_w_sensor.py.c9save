{"ts":1360100021576,"silentsave":true,"restoring":false,"patch":[[{"diffs":[[1,"#!/usr/bin/env python\n#\n# Copyright 2010,2011 Free Software Foundation, Inc.\n# \n# This file is part of GNU Radio\n# \n# GNU Radio is free software; you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation; either version 3, or (at your option)\n# any later version.\n# \n# GNU Radio is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n# GNU General Public License for more details.\n# \n# You should have received a copy of the GNU General Public License\n# along with GNU Radio; see the file COPYING.  If not, write to\n# the Free Software Foundation, Inc., 51 Franklin Street,\n# Boston, MA 02110-1301, USA.\n# \n\n# Modified from uhd_interface.py\n# Add a uhd_sensor \n\nfrom gnuradio import gr, uhd\nfrom gnuradio import eng_notation\nfrom gnuradio.eng_option import eng_option\nfrom optparse import OptionParser\n\nimport time, threading\nimport sys\n\n# streaming(0) or finite acqusition(1)\nSTREAM_OR_FINITE = 0\n\ndef add_freq_option(parser):\n    \"\"\"\n    Hackery that has the -f / --freq option set both tx_freq and rx_freq\n    \"\"\"\n    def freq_callback(option, opt_str, value, parser):\n        parser.values.rx_freq = value\n        parser.values.tx_freq = value\n\n    if not parser.has_option('--freq'):\n        parser.add_option('-f', '--freq', type=\"eng_float\",\n                          action=\"callback\", callback=freq_callback,\n                          help=\"set Tx and/or Rx frequency to FREQ [default=%default]\",\n                          metavar=\"FREQ\")\n\nclass uhd_interface:\n    def __init__(self, istx, addr, sym_rate, sps, samp_rate=None, freq=None,\n                 gain=None, spec=None, antenna=None):\n        \n        if(istx): \n            self.u = uhd.usrp_sink(device_addr=addr, stream_args=uhd.stream_args('fc32'))\n        else: \n            self.u = uhd.usrp_source(device_addr=addr, stream_args=uhd.stream_args('fc32'))\n\n        # Set the subdevice spec\n        if(spec):\n            self.u.set_subdev_spec(spec, 0)\n\n        # Set the antenna\n        #if(antenna):\n        if(istx):\n            print 'set the antenna to TX/RX'\n            self.u.set_antenna('TX/RX', 0)\n        else:\n            print 'set the antenna to RX2'\n            self.u.set_antenna('TX/RX', 0)\n        \n        #self._args = args\n        self._addr = addr\n        self._ant  = antenna\n        self._spec = spec\n        self._gain = self.set_gain(gain)\n        self._freq = self.set_freq(freq)\n\n        self._rate, self._sps = self.set_sample_rate(sym_rate, sps, samp_rate)\n        \n        #setup the USRP time monitor\n        #the corresponding thread would monitor the USRP time and the\n        #PC time, then put the latest time to the messge queue \n        #Users of the message can get the latest time difference between\n        #PC time and USRP time\n        if(istx):\n            self.tdiff_register = gr.msg_queue()\n            self.update_time_diff(self.u)\n        #the thread to monitor the PC time and the USRP time periodically\n            \n\n    def set_sample_rate(self, sym_rate, req_sps, direct_rate=None):\n        start_sps = req_sps\n        while(True):\n            if direct_rate is None:\n                asked_samp_rate = sym_rate * req_sps\n            else:\n                asked_samp_rate = direct_rate\n            self.u.set_samp_rate(asked_samp_rate)\n            actual_samp_rate = self.u.get_samp_rate()\n\n            sps = actual_samp_rate/sym_rate\n            if(sps < 2):\n                req_sps +=1\n            else:\n                actual_sps = sps\n                break\n        \n        if(sps != req_sps):\n            print \"\\nSymbol Rate:         %f\" % (sym_rate)\n            print \"Requested sps:       %f\" % (start_sps)\n            print \"Given sample rate:   %f\" % (actual_samp_rate)\n            print \"Actual sps for rate: %f\" % (actual_sps)\n\n        if(actual_samp_rate != asked_samp_rate):\n            print \"\\nRequested sample rate: %f\" % (asked_samp_rate)\n            print \"Actual sample rate: %f\" % (actual_samp_rate)\n\n        return (actual_samp_rate, actual_sps)\n\n    def get_sample_rate(self):\n        return self.u.get_samp_rate()\n    \n    def set_gain(self, gain=None):\n        if gain is None:\n            # if no gain was specified, use the mid-point in dB\n            g = self.u.get_gain_range()\n            gain = float(g.start()+g.stop())/2\n            print \"\\nNo gain specified.\"\n            print \"Setting gain to %f (from [%f, %f])\" % \\\n                (gain, g.start(), g.stop())\n        \n        self.u.set_gain(gain, 0)\n        return gain\n\n    def set_freq(self, freq=None):\n        if(freq is None):\n            sys.stderr.write(\"You must specify -f FREQ or --freq FREQ\\n\")\n            sys.exit(1)\n        \n        r = self.u.set_center_freq(freq, 0)\n        if r:\n            return freq\n        else:\n            frange = self.u.get_freq_range()\n            sys.stderr.write((\"\\nRequested frequency (%f) out or range [%f, %f]\\n\") % \\\n                                 (freq, frange.start(), frange.stop()))\n            sys.exit(1)\n\n    def update_time_diff(self, usrp):\n        msg = self.generate_time_diff(usrp)\n        while (self.tdiff_register.delete_head_nowait()):\n            continue\n        self.tdiff_register.insert_tail(msg)\n        threading.Timer(10, self.update_time_diff).start()           \n     \n    def generate_time_diff(self, usrp):\n        pc_time = time.time()\n        usrp_time = usrp.get_time_now().get_real_secs() + 0.00075\n        time_diff = struct.pack('!d', pc_time - usrp_time)\n        print time_diff\n        msg = gr.message_from_string(time_diff)\n        \n        return msg\n        \n#-------------------------------------------------------------------#\n#   TRANSMITTER\n#-------------------------------------------------------------------#\n\nclass uhd_transmitter(uhd_interface, gr.hier_block2):\n    def __init__(self, addr, sym_rate, sps, frate=None, freq=None, gain=None,\n                 spec=None, antenna=None, verbose=False, tdma=False):\n        gr.hier_block2.__init__(self, \"uhd_transmitter\",\n                                gr.io_signature(1,1,gr.sizeof_gr_complex),\n                                gr.io_signature(0,0,0))\n\n        # Set up the UHD interface as a transmitter\n        uhd_interface.__init__(self, True, addr, sym_rate, sps, frate,\n                               freq, gain, spec, antenna)\n\n        if(tdma): # add the tdma throttle before the uhd_sink\n\t    s_time = uhd.time_spec_t(self.u.get_time_now().get_real_secs() + 1)\n\t    self.tdma_throttle = uhd.pulse_source(s_time.get_full_secs(),\n\t\t\t\t\t\ts_time.get_frac_secs(),\n\t\t\t\t\t\tself.get_sample_rate(),\t\t\t\t\t\t\t\t\t\t\t  \n\t\t\t\t\t\t0.64, #idle duration\n\t\t\t\t\t\t0.16, #burst duration\n\t\t\t\t\t\t1) # accept input data\n\t    self.connect(self, self.tdma_throttle, self.u)\n        else: # Normal transmitter\n            self.connect(self, self.u)\n\n        if(verbose):\n            self._print_verbage()\n            \n    def add_options(parser):\n        add_freq_option(parser)\n        parser.add_option(\"-a\", \"--args\", type=\"string\", default=\"\",\n                          help=\"UHD device address args [default=%default]\")\n        parser.add_option(\"\", \"--tx-addr\", type=\"string\", default=\"\",\n                          help=\"UHD device address args [default=%default]\")\n        parser.add_option(\"\", \"--tx-spec\", type=\"string\", default=None,\n                          help=\"Subdevice of UHD device where appropriate\")\n        parser.add_option(\"\", \"--tx-antenna\", type=\"string\", default=None,\n                          help=\"select Rx Antenna where appropriate\")\n        parser.add_option(\"\", \"--tx-freq\", type=\"eng_float\", default=None,\n                          help=\"set transmit frequency to FREQ [default=%default]\",\n                          metavar=\"FREQ\")\n        parser.add_option(\"\", \"--tx-gain\", type=\"eng_float\", default=None,\n                          help=\"set transmit gain in dB (default is midpoint)\")\n        parser.add_option(\"-v\", \"--verbose\", action=\"store_true\", default=False)\n        parser.add_option(\"\", \"--tx-samprate\", type=\"eng_float\", default=None,\n                          help=\"set sample rate for transmitter [default=%default]\")\n\n    # Make a static method to call before instantiation\n    add_options = staticmethod(add_options)\n\n    def _print_verbage(self):\n        \"\"\"\n        Prints information about the UHD transmitter\n        \"\"\"\n        print \"\\nUHD Transmitter:\"\n        print \"UHD TX Addr:     %s\"    % (self._addr)\n        print \"Freq:        %sHz\"  % (eng_notation.num_to_str(self._freq))\n        print \"Gain:        %f dB\" % (self._gain)\n        print \"Sample Rate: %ssps\" % (eng_notation.num_to_str(self._rate))\n        print \"Antenna:     %s\"    % (self._ant)\n        print \"Subdev Sec:  %s\"    % (self._spec)\n\n\n#-------------------------------------------------------------------#\n#   RECEIVER\n#-------------------------------------------------------------------#\n\n\nclass uhd_receiver(uhd_interface, gr.hier_block2):\n    def __init__(self, addr, sym_rate, sps, freq=None, gain=None,\n                 spec=None, antenna=None, verbose=False):\n        gr.hier_block2.__init__(self, \"uhd_receiver\",\n                                gr.io_signature(0,0,0),\n                                gr.io_signature(1,1,gr.sizeof_gr_complex))\n      \n        # Set up the UHD interface as a receiver\n        uhd_interface.__init__(self, False, addr, sym_rate, sps,\n                               freq, gain, spec, antenna)\n\n        self.connect(self.u, self)\n\n        if(verbose):\n            self._print_verbage()\n\n    def add_options(parser):\n        add_freq_option(parser)\n        parser.add_option(\"\", \"--rx-addr\", type=\"string\", default=\"\",\n                          help=\"UHD device address args [default=%default]\")\n        parser.add_option(\"\", \"--rx-spec\", type=\"string\", default=None,\n                          help=\"Subdevice of UHD device where appropriate\")\n        parser.add_option(\"\", \"--rx-antenna\", type=\"string\", default=None,\n                          help=\"select Rx Antenna where appropriate\")\n        parser.add_option(\"\", \"--rx-freq\", type=\"eng_float\", default=None,\n                          help=\"set receive frequency to FREQ [default=%default]\",\n                          metavar=\"FREQ\")\n        parser.add_option(\"\", \"--rx-gain\", type=\"eng_float\", default=None,\n                          help=\"set receive gain in dB (default is midpoint)\")\n        if not parser.has_option(\"--verbose\"):\n            parser.add_option(\"-v\", \"--verbose\", action=\"store_true\", default=False)\n\n    # Make a static method to call before instantiation\n    add_options = staticmethod(add_options)\n\n    def _print_verbage(self):\n        \"\"\"\n        Prints information about the UHD transmitter\n        \"\"\"\n        print \"\\nUHD Receiver:\"\n        print \"UHD Receiver Addr:  %s\"    % (self._addr)\n        print \"Freq:        %sHz\"  % (eng_notation.num_to_str(self._freq))\n        print \"Gain:        %f dB\" % (self._gain)\n        print \"Sample Rate: %ssps\" % (eng_notation.num_to_str(self._rate))\n        print \"Antenna:     %s\"    % (self._ant)\n        print \"Spec:        %s\"    % (self._spec)\n\n        \n#-------------------------------------------------------------------#\n#   SENSOR\n#-------------------------------------------------------------------#       \nclass uhd_sensor(uhd_interface, gr.hier_block2):\n    def __init__(self, addr, samp_rate, freq=None, gain=None,\n                 spec=None, antenna=None, verbose=False):\n        gr.hier_block2.__init__(self, \"uhd_sensor\",\n                                gr.io_signature(0,0,0),\n                                gr.io_signature(1,1,gr.sizeof_gr_complex))\n      \n        self.u = uhd.usrp_source(device_addr=addr, stream_args=uhd.stream_args('fc32'))\n\n        # Set the subdevice spec\n        if(spec):\n            self.u.set_subdev_spec(spec, 0)\n\n        # Set the antenna\n        if(antenna):\n            self.u.set_antenna(antenna, 0)\n            \n        # Set the streaming of the source as start on demand\n        # tb.start will not start streaming right now\n        # the streaming will only be started after the sensor \n        # receives the demand\n        if (STREAM_OR_FINITE == 0):\n            self.u.set_start_on_demand()\n        \n        self._addr = addr\n        self._ant  = antenna\n        self._spec = spec\n        self._gain = self.set_gain(gain)\n        self._freq = self.set_freq(freq)\n\n        # Set the sample rate\n        if(samp_rate is None):\n            sys.stderr.write(\"You must specify --sx-samprate for uhd sensor\\n\")\n            sys.exit(1)            \n        else:\n            self._rate = self.u.set_samp_rate(samp_rate)\n\n        self.connect(self.u, self)\n\n        if(verbose):\n            self._print_verbage()\n\n    def add_options(parser):\n        add_freq_option(parser)\n        parser.add_option(\"\", \"--sx-addr\", type=\"string\", default=\"\",\n                          help=\"UHD device address args [default=%default]\")\n        parser.add_option(\"\", \"--sx-spec\", type=\"string\", default=None,\n                          help=\"Subdevice of UHD device where appropriate\")\n        parser.add_option(\"\", \"--sx-antenna\", type=\"string\", default=None,\n                          help=\"select Sx Antenna where appropriate\")\n        parser.add_option(\"\", \"--sx-freq\", type=\"eng_float\", default=None,\n                          help=\"set sensing frequency to FREQ [default=%default]\",\n                          metavar=\"FREQ\")\n        parser.add_option(\"\", \"--sx-samprate\", type=\"eng_float\", default=None,\n                          help=\"set sample rate for sensor to [default=%default]\")\n        parser.add_option(\"\", \"--sx-gain\", type=\"eng_float\", default=None,\n                          help=\"set sensor gain in dB (default is midpoint)\")\n        if not parser.has_option(\"--verbose\"):\n            parser.add_option(\"-v\", \"--verbose\", action=\"store_true\", default=False)\n\n    # Make a static method to call before instantiation\n    add_options = staticmethod(add_options)\n\n    def _print_verbage(self):\n        \"\"\"\n        Prints information about the UHD transmitter\n        \"\"\"\n        print \"\\nUHD Receiver:\"\n        print \"UHD Addrs:    %s\"    % (self._addr)\n        print \"Freq:        %sHz\"  % (eng_notation.num_to_str(self._freq))\n        print \"Gain:        %f dB\" % (self._gain)\n        print \"Sample Rate: %ssps\" % (eng_notation.num_to_str(self._rate))\n        print \"Antenna:     %s\"    % (self._ant)\n        print \"Spec:        %s\"    % (self._spec)        \n        \n"]],"start1":0,"start2":0,"length1":0,"length2":14641}]],"length":14641}
{"contributors":[],"silentsave":true,"ts":1360100036199,"patch":[[{"diffs":[[0,"reading\n"],[1,"imp\n"],[0,"import s"]],"start1":1025,"start2":1025,"length1":16,"length2":20}]],"length":14645,"saved":false}
{"ts":1360100039200,"patch":[[{"diffs":[[0,"ding\nimp"],[1,"ort struct"],[0,"\nimport "]],"start1":1028,"start2":1028,"length1":16,"length2":26}]],"length":14655,"saved":false}
