<?xml version='1.0' encoding='UTF-8' standalone='no'?>
<doxygen xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="compound.xsd" version="1.7.6.1">
  <compounddef id="volk_guide" kind="page">
    <compoundname>volk_guide</compoundname>
    <title>Instructions for using Volk in GNU Radio</title>
    <detaileddescription>
<sect1 id="volk_guide_1volk_intro">
<title>Introduction</title>
<para>Volk is the Vector-Optimized Library of Kernels. It is a library that contains kernels of hand-written SIMD code for different mathematical operations. Since each SIMD architecture can be greatly different and no compiler has yet come along to handle vectorization properly or highly efficiently, Volk approaches the problem differently. For each architecture or platform that a developer wishes to vectorize for, a new proto-kernel is added to Volk. At runtime, Volk will select the correct proto-kernel. In this way, the users of Volk call a kernel for performing the operation that is platform/architecture agnostic. This allows us to write portable SIMD code.</para><para>Volk kernels are always defined with a &apos;generic&apos; proto-kernel, which is written in plain C. With the generic kernel, the kernel becomes portable to any platform. Kernels are then extended by adding proto-kernels for new platforms in which they are desired.</para><para>A good example of a Volk kernel with multiple proto-kernels defined is the volk_32f_s32f_multiply_32f_a. This kernel implements a scalar multiplication of a vector of floating point numbers (each item in the vector is multiplied by the same value). This kernel has the following proto-kernels that are defined for &apos;generic,&apos; &apos;avx,&apos; &apos;sse,&apos; and &apos;orc.&apos;</para><para><programlisting><codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>volk_32f_s32f_multiply_32f_a_generic</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>volk_32f_s32f_multiply_32f_a_sse</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>volk_32f_s32f_multiply_32f_a_avx</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>volk_32f_s32f_multiply_32f_a_orc</highlight></codeline>
</programlisting></para><para>These proto-kernels means that on platforms with AVX support, Volk can select this option or the SSE option, depending on which is faster. On other platforms, the ORC SIMD compiler might provide a solution. If all else fails, Volk can fall back on the generic proto-kernel, which will always work.</para><para>Just a note on ORC. ORC is a SIMD compiler library that uses a generic assembly-like language for SIMD commands. Based on the available SIMD architecture of a system, it will try and compile a good solution. Tests show that the results of ORC proto-kernels are generally better than the generic versions but often not as good as the hand-tuned proto-kernels for a specific SIMD architecture. This is, of course, to be expected, and ORC provides a nice intermediary step to performance improvements until a specific hand-tuned proto-kernel can be made for a given platform.</para><para>See <ulink url="http://gnuradio.org/redmine/projects/gnuradio/wiki/Volk">Volk on gnuradio.org</ulink> for details on the Volk naming scheme.</para></sect1>
<sect1 id="volk_guide_1volk_alignment">
<title>Setting and Using Memory Alignment Information</title>
<para>For Volk to work as best as possible, we want to use memory-aligned SIMD calls, which means we have to have some way of knowing and controlling the alignment of the buffers passed to <ref refid="classgr__block" kindref="compound">gr_block</ref>&apos;s work function. We set the alignment requirement for SIMD aligned memory calls with:</para><para><programlisting><codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>alignment_multiple<sp/>=</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="volk_8h_1a1bedaae028349fdd660fe18343f4d941" kindref="member">volk_get_alignment</ref>()<sp/>/<sp/>output_item_size;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>set_alignment(alignment_multiple);</highlight></codeline>
</programlisting></para><para>The Volk function &apos;volk_get_alignment&apos; provides the alignment of the the machine architecture. We then base the alignment on the number of output items required to maintain the alignment, so we divide the number of alignment bytes by the number of bytes in an output items (sizeof(float), sizeof(gr_complex), etc.). This value is then set per block with the &apos;set_alignment&apos; function.</para><para>Because the scheduler tries to optimize throughput, the number of items available per call to work will change and depends on the availability of the read and write buffers. This means that it sometimes cannot produce a buffer that is properly memory aligned. This is an inevitable consequence of the scheduler system. Instead of requiring alignment, the scheduler enforces the alignment as much as possible, and when a buffer becomes unaligned, the scheduler will work to correct it as much as possible. If a block&apos;s buffers are unaligned, then, the scheduler sets a flag to indicate as much so that the block can then decide what best to do. The next section discusses the use of the aligned/unaligned information in a <ref refid="classgr__block" kindref="compound">gr_block</ref>&apos;s work function.</para></sect1>
<sect1 id="volk_guide_1volk_work">
<title>Using Alignment Properties in Work()</title>
<para>The buffers passed to work/general_work in a <ref refid="classgr__block" kindref="compound">gr_block</ref> are not guaranteed to be aligned, but they will mostly be aligned whenever possible. When not aligned, the &apos;is_unaligned()&apos; flag will be set. So a block can know if its buffers are aligned and make the right decisions. This looks like:</para><para><programlisting><codeline><highlight class="keywordtype">int</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal">gr_some_block::work<sp/>(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>noutput_items,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><ref refid="gr__types_8h_1a9852a3d906d823cb70eb9c29e7f2a43d" kindref="member">gr_vector_const_void_star</ref><sp/>&amp;input_items,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><ref refid="gr__types_8h_1acd3f499576e769966ea44554b359d949" kindref="member">gr_vector_void_star</ref><sp/>&amp;output_items)</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">float</highlight><highlight class="normal"><sp/>*in<sp/>=<sp/>(</highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">float</highlight><highlight class="normal"><sp/>*)<sp/>input_items[0];</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordtype">float</highlight><highlight class="normal"><sp/>*out<sp/>=<sp/>(</highlight><highlight class="keywordtype">float</highlight><highlight class="normal"><sp/>*)<sp/>output_items[0];</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal">(is_unaligned())<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>do<sp/>something<sp/>with<sp/>unaligned<sp/>data.<sp/>This<sp/>can<sp/>either<sp/>be<sp/>a<sp/>manual</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>handling<sp/>of<sp/>the<sp/>items<sp/>or<sp/>a<sp/>call<sp/>to<sp/>an<sp/>unaligned<sp/>Volk<sp/>function.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>volk_32f_something_32f_u(out,<sp/>in,<sp/>noutput_items);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Buffers<sp/>are<sp/>aligned;<sp/>can<sp/>call<sp/>the<sp/>aligned<sp/>Volk<sp/>function.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>volk_32f_something_32f_a(out,<sp/>in,<sp/>noutput_items);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>noutput_items;</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
</programlisting></para></sect1>
<sect1 id="volk_guide_1volk_tuning">
<title>Tuning Volk Performance</title>
<para>VOLK comes with a profiler that will build a config file for the best SIMD architecture for your processor. Run volk_profile that is installed into $PREFIX/bin. This program tests all known VOLK kernels for each architecture supported by the processor. When finished, it will write to $HOME/.volk/volk_config the best architecture for the VOLK function. This file is read when using a function to know the best version of the function to execute.</para><sect2 id="volk_guide_1volk_hand_tuning">
<title>Hand-Tuning Performance</title>
<para>If you know a particular architecture works best for your processor, you can specify the particular architecture to use in the VOLK preferences file: $HOME/.volk/volk_config</para><para>The file looks like:</para><para><programlisting><codeline><highlight class="normal"><sp/><sp/><sp/><sp/>volk_&lt;FUNCTION_NAME&gt;<sp/>&lt;ARCHITECTURE&gt;</highlight></codeline>
</programlisting></para><para>Where the &quot;FUNCTION_NAME&quot; is the particular function that you want to over-ride the default value and &quot;ARCHITECTURE&quot; is the VOLK SIMD architecture to use (generic, sse, sse2, sse3, avx, etc.). For example, the following config file tells VOLK to use SSE3 for the aligned and unaligned versions of a function that multiplies two complex streams together.</para><para><programlisting><codeline><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="volk_8h_1af39887da3fa314aaffca586a95559988" kindref="member">volk_32fc_x2_multiply_32fc_a</ref><sp/>sse3</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="volk_8h_1ae9bb819fed06b7d198099ca7b716f3fa" kindref="member">volk_32fc_x2_multiply_32fc_u</ref><sp/>sse3</highlight></codeline>
</programlisting></para><para><bold>Tip:</bold> if benchmarking GNU Radio blocks, it can be useful to have a volk_config file that sets all architectures to &apos;generic&apos; as a way to test the vectorized versus non-vectorized implementations. </para></sect2>
</sect1>
    </detaileddescription>
  </compounddef>
</doxygen>
