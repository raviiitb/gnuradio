<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<title>GNU Radio 3.6.1git-182-gab9a06f0 C++ API: Polyphase Filterbanks</title>

<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>


</head>
<body>
<div id="top"><!-- do not remove this div! -->


<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  
  
  <td style="padding-left: 0.5em;">
   <div id="projectname">GNU Radio 3.6.1git-182-gab9a06f0 C++ API
   
   </div>
   
  </td>
  
  
  
   
  
 </tr>
 </tbody>
</table>
</div>

<!-- Generated by Doxygen 1.7.6.1 -->
</div>
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
  initNavTree('page_pfb.html','');
</script>
<div id="doc-content">
<div class="header">
  <div class="headertitle">
<div class="title">Polyphase Filterbanks </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><h2><a class="anchor" id="Introduction"></a>
Introduction</h2>
<p>Polyphase filterbanks (PFB) are a very powerful set of filtering tools that can efficiently perform many multi-rate signal processing tasks. GNU Radio has a set of polyphase filterbank blocks to be used in all sorts of applications. These blocks and their documentation can be found in <a class="el" href="group__pfb__blk.html">Polyphase Filterbank</a>.</p>
<h2><a class="anchor" id="Usage"></a>
Usage</h2>
<p>See the documentation for the individual blocks for details about what they can do and how they should be used. Furthermore, there are examples for these blocks in <b>gnuradio-examples/python/pfb</b>.</p>
<p>The main issue when using the PFB blocks is defining the prototype filter, which is passed to all of the blocks as a vector of <code>taps</code>. The taps from the prototype filter which get partitioned among the <code>N</code> channels of the channelizer.</p>
<p>An example of creating a set of filter taps for a PFB channelizer is found on line 49 of <b>gnuradio-examples/python/pfb/channelizer.py</b> and reproduced below. Notice that the sample rate is the sample rate at the input to the channelizer while the bandwidth and transition width are defined for the channel bandwidths. This makes a fairly long filter that is then split up between the <code>N</code> channels of the PFB.</p>
<div class="fragment"><pre class="fragment">    <span class="keyword">self</span>._fs = 9000          # input sample rate
    <span class="keyword">self</span>._M = 9              # Number of channels to channelize

    <span class="keyword">self</span>._taps = gr.firdes.low_pass_2(1, <span class="keyword">self</span>._fs, 475.50, 50,
                                      attenuation_dB=100,
                                      window=gr.firdes.WIN_BLACKMAN_hARRIS)
</pre></div><p>In this example, the signal into the channelizer is sampled at 9 ksps (complex, so 9 kHz of bandwidth). The filter uses 9 channels, so each output channel will have a bandwidth and sample rate of 1 kHz. We want to pass most of the channel, so we define the channel bandwidth to be a low pass filter with a bandwidth of 475.5 Hz and a transition bandwidth of 50 Hz, but we have defined this using a sample rate of the original 9 kHz. The prototype filter has 819 taps to be divided up between the 9 channels, so each channel uses 91 taps. This is probably over-kill for a channelizer, and we could reduce the amount of taps per channel to a couple of dozen with no ill effects.</p>
<p>The basic rule when defining a set of taps for a PFB block is to think about the filter running at the highest rate it will see while the bandwidth is defined for the size of the channels. In the channelizer case, the highest rate is defined as the rate of the incoming signal, but in other PFB blocks, this is not so obvious.</p>
<p>Two very useful blocks to use are the arbitrary resampler and the clock synchronizer (for PAM signals). These PFBs are defined with a set number of filters based on the fidelity required from them, not the rate changes. By default, the <code>filter_size</code> is set to 32 for these blocks, which is a reasonable default for most tasks. Because the PFB uses this number of filters in the filterbank, the maximum rate of the bank is defined from this (see the theory of a polyphase interpolator for a justification of this). So the prototype filter is defined to use a sample rate of <code>filter_size</code> times the signal's sampling rate.</p>
<p>A helpful wrapper for the arbitrary resampler is found in <b>gnuradio-core/src/python/gnuradio/blks2impl/pfb_arb_resampler.py</b>, which is exposed in Python as <b>blks2.pfb_arb_resampler_ccf</b> and <b>blks2.pfb_arb_resampler_fff</b>. This block is set up so that the user only needs to pass it the real number <code>rate</code> as the resampling rate. With just this information, this hierarchical block automatically creates a filter that fully passes the signal bandwidth being resampled but does not pass any out-of-band noise. See the code for this block for details of how the filter is constructed.</p>
<p>Of course, a user can create his or her own taps and use them in the arbitrary resampler for more specific requirements. Some of the UHD examples (<b>gr-uhd/examples</b>) use this ability to create a received matched filter or channel filter that also resamples the signal.</p>
<h2><a class="anchor" id="Examples"></a>
Examples</h2>
<p>The following is an example of the using the channelizer. It creates the appropriate filter to channelizer 9 channels out of an original signal that is 9000 Hz wide, so each output channel is now 1000 Hz. The code then plots the PSD of the original signal to see the signals in the origina spectrum and then makes 9 plots for each of the channels.</p>
<p>NOTE: you need the Scipy and Matplotlib Python modules installed to run this example.</p>
<div class="fragment"><pre class="fragment"><span class="comment">#!/usr/bin/env python</span>
<span class="comment">#</span>
<span class="comment"># Copyright 2009 Free Software Foundation, Inc.</span>
<span class="comment">#</span>
<span class="comment"># This file is part of GNU Radio</span>
<span class="comment">#</span>
<span class="comment"># GNU Radio is free software; you can redistribute it and/or modify</span>
<span class="comment"># it under the terms of the GNU General Public License as published by</span>
<span class="comment"># the Free Software Foundation; either version 3, or (at your option)</span>
<span class="comment"># any later version.</span>
<span class="comment">#</span>
<span class="comment"># GNU Radio is distributed in the hope that it will be useful,</span>
<span class="comment"># but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<span class="comment"># MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</span>
<span class="comment"># GNU General Public License for more details.</span>
<span class="comment">#</span>
<span class="comment"># You should have received a copy of the GNU General Public License</span>
<span class="comment"># along with GNU Radio; see the file COPYING.  If not, write to</span>
<span class="comment"># the Free Software Foundation, Inc., 51 Franklin Street,</span>
<span class="comment"># Boston, MA 02110-1301, USA.</span>
<span class="comment">#</span>

<span class="keyword">from</span> gnuradio <span class="keyword">import</span> gr, blks2
<span class="keyword">import</span> sys, time

<span class="keywordflow">try</span>:
    <span class="keyword">import</span> scipy
    <span class="keyword">from</span> scipy <span class="keyword">import</span> fftpack
<span class="keywordflow">except</span> ImportError:
    <span class="keywordflow">print</span> <span class="stringliteral">&quot;Error: Program requires scipy (see: www.scipy.org).&quot;</span>
    sys.exit(1)

<span class="keywordflow">try</span>:
    <span class="keyword">import</span> pylab
    <span class="keyword">from</span> pylab <span class="keyword">import</span> mlab
<span class="keywordflow">except</span> ImportError:
    <span class="keywordflow">print</span> <span class="stringliteral">&quot;Error: Program requires matplotlib (see: matplotlib.sourceforge.net).&quot;</span>
    sys.exit(1)

<span class="keyword">class </span>pfb_top_block(gr.top_block):
    <span class="keyword">def </span>__init__(self):
        gr.top_block.__init__(self)

        self._N = 2000000        <span class="comment"># number of samples to use</span>
        self._fs = 9000          <span class="comment"># initial sampling rate</span>
        self._M = 9              <span class="comment"># Number of channels to channelize</span>

        <span class="comment"># Create a set of taps for the PFB channelizer</span>
        self._taps = gr.firdes.low_pass_2(1, self._fs, 475.50, 50,
                                          attenuation_dB=100, window=gr.firdes.WIN_BLACKMAN_hARRIS)

        <span class="comment"># Calculate the number of taps per channel for our own information</span>
        tpc = scipy.ceil(float(len(self._taps)) /  float(self._M))
        <span class="keywordflow">print</span> <span class="stringliteral">&quot;Number of taps:     &quot;</span>, len(self._taps)
        <span class="keywordflow">print</span> <span class="stringliteral">&quot;Number of channels: &quot;</span>, self._M
        <span class="keywordflow">print</span> <span class="stringliteral">&quot;Taps per channel:   &quot;</span>, tpc

        <span class="comment"># Create a set of signals at different frequencies</span>
        <span class="comment">#   freqs lists the frequencies of the signals that get stored</span>
        <span class="comment">#   in the list &quot;signals&quot;, which then get summed together</span>
        self.signals = list()
        self.add = gr.add_cc()
        freqs = [-4070, -3050, -2030, -1010, 10, 1020, 2040, 3060, 4080]
        <span class="keywordflow">for</span> i <span class="keywordflow">in</span> xrange(len(freqs)):
            self.signals.append(gr.sig_source_c(self._fs, gr.GR_SIN_WAVE, freqs[i], 1))
            self.connect(self.signals[i], (self.add,i))

        self.head = gr.head(gr.sizeof_gr_complex, self._N)

        <span class="comment"># Construct the channelizer filter</span>
        self.pfb = blks2.pfb_channelizer_ccf(self._M, self._taps, 1)

        <span class="comment"># Construct a vector sink for the input signal to the channelizer</span>
        self.snk_i = gr.vector_sink_c()

        <span class="comment"># Connect the blocks</span>
        self.connect(self.add, self.head, self.pfb)
        self.connect(self.add, self.snk_i)

        <span class="comment"># Use this to play with the channel mapping</span>
        <span class="comment">#self.pfb.set_channel_map([5,6,7,8,0,1,2,3,4])</span>

        <span class="comment"># Create a vector sink for each of M output channels of the filter and connect it</span>
        self.snks = list()
        <span class="keywordflow">for</span> i <span class="keywordflow">in</span> xrange(self._M):
            self.snks.append(gr.vector_sink_c())
            self.connect((self.pfb, i), self.snks[i])


<span class="keyword">def </span><a class="code" href="aadvark_8h.html#ae66f6b31b5ad750f1fe042a706a4e3d4">main</a>():
    tstart = time.time()

    tb = pfb_top_block()
    tb.run()

    tend = time.time()
    <span class="keywordflow">print</span> <span class="stringliteral">&quot;Run time: %f&quot;</span> % (tend - tstart)

    <span class="keywordflow">if</span> 1:
        fig_in = pylab.figure(1, figsize=(16,9), facecolor=<span class="stringliteral">&quot;w&quot;</span>)
        fig1 = pylab.figure(2, figsize=(16,9), facecolor=<span class="stringliteral">&quot;w&quot;</span>)
        fig2 = pylab.figure(3, figsize=(16,9), facecolor=<span class="stringliteral">&quot;w&quot;</span>)

        Ns = 1000
        Ne = 10000

        fftlen = 8192
        winfunc = scipy.blackman
        fs = tb._fs

        <span class="comment"># Plot the input signal on its own figure</span>
        d = tb.snk_i.data()[Ns:Ne]
        spin_f = fig_in.add_subplot(2, 1, 1)

        X,freq = mlab.psd(d, NFFT=fftlen, noverlap=fftlen/4, Fs=fs,
                          window = <span class="keyword">lambda</span> d: d*winfunc(fftlen),
                          scale_by_freq=<span class="keyword">True</span>)
        X_in = 10.0*scipy.log10(abs(X))
        f_in = scipy.arange(-fs/2.0, fs/2.0, fs/float(X_in.size))
        pin_f = spin_f.plot(f_in, X_in, <span class="stringliteral">&quot;b&quot;</span>)
        spin_f.set_xlim([<a class="code" href="core__algorithms_8h.html#a8ee42a5dd83886e7ad61d451d5a32956">min</a>(f_in), max(f_in)+1])
        spin_f.set_ylim([-200.0, 50.0])

        spin_f.set_title(<span class="stringliteral">&quot;Input Signal&quot;</span>, weight=<span class="stringliteral">&quot;bold&quot;</span>)
        spin_f.set_xlabel(<span class="stringliteral">&quot;Frequency (Hz)&quot;</span>)
        spin_f.set_ylabel(<span class="stringliteral">&quot;Power (dBW)&quot;</span>)


        Ts = 1.0/fs
        Tmax = len(d)*Ts

        t_in = scipy.arange(0, Tmax, Ts)
        x_in = scipy.array(d)
        spin_t = fig_in.add_subplot(2, 1, 2)
        pin_t = spin_t.plot(t_in, x_in.real, <span class="stringliteral">&quot;b&quot;</span>)
        pin_t = spin_t.plot(t_in, x_in.imag, <span class="stringliteral">&quot;</span><span class="stringliteral">r&quot;)</span>
<span class="stringliteral"></span>
<span class="stringliteral">        spin_t.set_xlabel(</span><span class="stringliteral">&quot;Time (s)&quot;</span>)
        spin_t.set_ylabel(<span class="stringliteral">&quot;Amplitude&quot;</span>)

        Ncols = int(scipy.floor(scipy.sqrt(tb._M)))
        Nrows = int(scipy.floor(tb._M / Ncols))
        if(tb._M % Ncols != 0):
            Nrows += 1

        <span class="comment"># Plot each of the channels outputs. Frequencies on Figure 2 and</span>
        <span class="comment"># time signals on Figure 3</span>
        fs_o = tb._fs / tb._M
        Ts_o = 1.0/fs_o
        Tmax_o = len(d)*Ts_o
        <span class="keywordflow">for</span> i <span class="keywordflow">in</span> xrange(len(tb.snks)):
            <span class="comment"># remove issues with the transients at the beginning</span>
            <span class="comment"># also remove some corruption at the end of the stream</span>
            <span class="comment">#    this is a bug, probably due to the corner cases</span>
            d = tb.snks[i].data()[Ns:Ne]

            sp1_f = fig1.add_subplot(Nrows, Ncols, 1+i)
            X,freq = mlab.psd(d, NFFT=fftlen, noverlap=fftlen/4, Fs=fs_o,
                              window = <span class="keyword">lambda</span> d: d*winfunc(fftlen),
                              scale_by_freq=<span class="keyword">True</span>)
            X_o = 10.0*scipy.log10(abs(X))
            f_o = scipy.arange(-fs_o/2.0, fs_o/2.0, fs_o/float(X_o.size))
            p2_f = sp1_f.plot(f_o, X_o, <span class="stringliteral">&quot;b&quot;</span>)
            sp1_f.set_xlim([<a class="code" href="core__algorithms_8h.html#a8ee42a5dd83886e7ad61d451d5a32956">min</a>(f_o), max(f_o)+1])
            sp1_f.set_ylim([-200.0, 50.0])

            sp1_f.set_title((<span class="stringliteral">&quot;Channel %d&quot;</span> % i), weight=<span class="stringliteral">&quot;bold&quot;</span>)
            sp1_f.set_xlabel(<span class="stringliteral">&quot;Frequency (Hz)&quot;</span>)
            sp1_f.set_ylabel(<span class="stringliteral">&quot;Power (dBW)&quot;</span>)

            x_o = scipy.array(d)
            t_o = scipy.arange(0, Tmax_o, Ts_o)
            sp2_o = fig2.add_subplot(Nrows, Ncols, 1+i)
            p2_o = sp2_o.plot(t_o, x_o.real, <span class="stringliteral">&quot;b&quot;</span>)
            p2_o = sp2_o.plot(t_o, x_o.imag, <span class="stringliteral">&quot;</span><span class="stringliteral">r&quot;)</span>
<span class="stringliteral">            sp2_o.set_xlim([<a class="code" href="core__algorithms_8h.html#a8ee42a5dd83886e7ad61d451d5a32956">min</a>(t_o), max(t_o)+1])</span>
<span class="stringliteral">            sp2_o.set_ylim([-2, 2])</span>
<span class="stringliteral"></span>
<span class="stringliteral">            sp2_o.set_title((</span><span class="stringliteral">&quot;Channel %d&quot;</span> % i), weight=<span class="stringliteral">&quot;bold&quot;</span>)
            sp2_o.set_xlabel(<span class="stringliteral">&quot;Time (s)&quot;</span>)
            sp2_o.set_ylabel(<span class="stringliteral">&quot;Amplitude&quot;</span>)

        pylab.show()


<span class="keywordflow">if</span> __name__ == <span class="stringliteral">&quot;__main__&quot;</span>:
    <span class="keywordflow">try</span>:
        <a class="code" href="aadvark_8h.html#ae66f6b31b5ad750f1fe042a706a4e3d4">main</a>()
    <span class="keywordflow">except</span> KeyboardInterrupt:
        <span class="keywordflow">pass</span>

</pre></div> </div></div><!-- contents -->
</div>
  <div id="nav-path" class="navpath">
    <ul>

    <li class="footer">Generated on Tue Jun 5 2012 16:56:55 for GNU Radio 3.6.1git-182-gab9a06f0 C++ API by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.6.1 </li>
   </ul>
 </div>


</body>
</html>
