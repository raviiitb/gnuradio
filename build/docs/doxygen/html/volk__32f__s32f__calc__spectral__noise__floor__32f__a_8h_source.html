<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<title>GNU Radio 3.6.1git-182-gab9a06f0 C++ API: volk_32f_s32f_calc_spectral_noise_floor_32f_a.h Source File</title>

<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>


</head>
<body>
<div id="top"><!-- do not remove this div! -->


<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  
  
  <td style="padding-left: 0.5em;">
   <div id="projectname">GNU Radio 3.6.1git-182-gab9a06f0 C++ API
   
   </div>
   
  </td>
  
  
  
   
  
 </tr>
 </tbody>
</table>
</div>

<!-- Generated by Doxygen 1.7.6.1 -->
</div>
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
  initNavTree('volk__32f__s32f__calc__spectral__noise__floor__32f__a_8h.html','');
</script>
<div id="doc-content">
<div class="header">
  <div class="headertitle">
<div class="title">volk_32f_s32f_calc_spectral_noise_floor_32f_a.h</div>  </div>
</div><!--header-->
<div class="contents">
<a href="volk__32f__s32f__calc__spectral__noise__floor__32f__a_8h.html">Go to the documentation of this file.</a><div class="fragment"><pre class="fragment"><a name="l00001"></a>00001 <span class="preprocessor">#ifndef INCLUDED_volk_32f_s32f_calc_spectral_noise_floor_32f_a_H</span>
<a name="l00002"></a>00002 <span class="preprocessor"></span><span class="preprocessor">#define INCLUDED_volk_32f_s32f_calc_spectral_noise_floor_32f_a_H</span>
<a name="l00003"></a>00003 <span class="preprocessor"></span>
<a name="l00004"></a>00004 <span class="preprocessor">#include &lt;<a class="code" href="volk__common_8h.html">volk/volk_common.h</a>&gt;</span>
<a name="l00005"></a>00005 <span class="preprocessor">#include &lt;<a class="code" href="inttypes_8h.html">inttypes.h</a>&gt;</span>
<a name="l00006"></a>00006 <span class="preprocessor">#include &lt;stdio.h&gt;</span>
<a name="l00007"></a>00007 
<a name="l00008"></a>00008 <span class="preprocessor">#ifdef LV_HAVE_SSE</span>
<a name="l00009"></a>00009 <span class="preprocessor"></span><span class="preprocessor">#include &lt;xmmintrin.h&gt;</span><span class="comment"></span>
<a name="l00010"></a>00010 <span class="comment">/*!</span>
<a name="l00011"></a>00011 <span class="comment">  \brief Calculates the spectral noise floor of an input power spectrum</span>
<a name="l00012"></a>00012 <span class="comment"></span>
<a name="l00013"></a>00013 <span class="comment">  Calculates the spectral noise floor of an input power spectrum by determining the mean of the input power spectrum, then recalculating the mean excluding any power spectrum values that exceed the mean by the spectralExclusionValue (in dB).  Provides a rough estimation of the signal noise floor.</span>
<a name="l00014"></a>00014 <span class="comment"></span>
<a name="l00015"></a>00015 <span class="comment">  \param realDataPoints The input power spectrum</span>
<a name="l00016"></a>00016 <span class="comment">  \param num_points The number of data points in the input power spectrum vector</span>
<a name="l00017"></a>00017 <span class="comment">  \param spectralExclusionValue The number of dB above the noise floor that a data point must be to be excluded from the noise floor calculation - default value is 20</span>
<a name="l00018"></a>00018 <span class="comment">  \param noiseFloorAmplitude The noise floor of the input spectrum, in dB</span>
<a name="l00019"></a>00019 <span class="comment">*/</span>
<a name="l00020"></a>00020 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">void</span> volk_32f_s32f_calc_spectral_noise_floor_32f_a_sse(<span class="keywordtype">float</span>* noiseFloorAmplitude, <span class="keyword">const</span> <span class="keywordtype">float</span>* realDataPoints, <span class="keyword">const</span> <span class="keywordtype">float</span> spectralExclusionValue, <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> num_points){
<a name="l00021"></a>00021   <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> number = 0;
<a name="l00022"></a>00022   <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> quarterPoints = num_points / 4;
<a name="l00023"></a>00023 
<a name="l00024"></a>00024   <span class="keyword">const</span> <span class="keywordtype">float</span>* dataPointsPtr = realDataPoints;
<a name="l00025"></a>00025   <a class="code" href="volk__common_8h.html#af8ae70079c1927f7c46b6d1880473d17">__VOLK_ATTR_ALIGNED</a>(16) float avgPointsVector[4];
<a name="l00026"></a>00026 
<a name="l00027"></a>00027   __m128 dataPointsVal;
<a name="l00028"></a>00028   __m128 avgPointsVal = _mm_setzero_ps();
<a name="l00029"></a>00029   <span class="comment">// Calculate the sum (for mean) for all points</span>
<a name="l00030"></a>00030   for(; number &lt; quarterPoints; number++){
<a name="l00031"></a>00031 
<a name="l00032"></a>00032     dataPointsVal = _mm_load_ps(dataPointsPtr);
<a name="l00033"></a>00033 
<a name="l00034"></a>00034     dataPointsPtr += 4;
<a name="l00035"></a>00035 
<a name="l00036"></a>00036     avgPointsVal = _mm_add_ps(avgPointsVal, dataPointsVal);
<a name="l00037"></a>00037   }
<a name="l00038"></a>00038 
<a name="l00039"></a>00039   _mm_store_ps(avgPointsVector, avgPointsVal);
<a name="l00040"></a>00040 
<a name="l00041"></a>00041   <span class="keywordtype">float</span> sumMean = 0.0;
<a name="l00042"></a>00042   sumMean += avgPointsVector[0];
<a name="l00043"></a>00043   sumMean += avgPointsVector[1];
<a name="l00044"></a>00044   sumMean += avgPointsVector[2];
<a name="l00045"></a>00045   sumMean += avgPointsVector[3];
<a name="l00046"></a>00046 
<a name="l00047"></a>00047   number = quarterPoints * 4;
<a name="l00048"></a>00048   <span class="keywordflow">for</span>(;number &lt; num_points; number++){
<a name="l00049"></a>00049     sumMean += realDataPoints[number];
<a name="l00050"></a>00050   }
<a name="l00051"></a>00051 
<a name="l00052"></a>00052   <span class="comment">// calculate the spectral mean</span>
<a name="l00053"></a>00053   <span class="comment">// +20 because for the comparison below we only want to throw out bins</span>
<a name="l00054"></a>00054   <span class="comment">// that are significantly higher (and would, thus, affect the mean more</span>
<a name="l00055"></a>00055   <span class="keyword">const</span> <span class="keywordtype">float</span> meanAmplitude = (sumMean / ((float)num_points)) + spectralExclusionValue;
<a name="l00056"></a>00056 
<a name="l00057"></a>00057   dataPointsPtr = realDataPoints; <span class="comment">// Reset the dataPointsPtr</span>
<a name="l00058"></a>00058   __m128 vMeanAmplitudeVector = _mm_set_ps1(meanAmplitude);
<a name="l00059"></a>00059   __m128 vOnesVector = _mm_set_ps1(1.0);
<a name="l00060"></a>00060   __m128 vValidBinCount = _mm_setzero_ps();
<a name="l00061"></a>00061   avgPointsVal = _mm_setzero_ps();
<a name="l00062"></a>00062   __m128 compareMask;
<a name="l00063"></a>00063   number = 0;
<a name="l00064"></a>00064   <span class="comment">// Calculate the sum (for mean) for any points which do NOT exceed the mean amplitude</span>
<a name="l00065"></a>00065   <span class="keywordflow">for</span>(; number &lt; quarterPoints; number++){
<a name="l00066"></a>00066 
<a name="l00067"></a>00067     dataPointsVal = _mm_load_ps(dataPointsPtr);
<a name="l00068"></a>00068 
<a name="l00069"></a>00069     dataPointsPtr += 4;
<a name="l00070"></a>00070 
<a name="l00071"></a>00071     <span class="comment">// Identify which items do not exceed the mean amplitude</span>
<a name="l00072"></a>00072     compareMask = _mm_cmple_ps(dataPointsVal, vMeanAmplitudeVector);
<a name="l00073"></a>00073 
<a name="l00074"></a>00074     <span class="comment">// Mask off the items that exceed the mean amplitude and add the avg Points that do not exceed the mean amplitude</span>
<a name="l00075"></a>00075     avgPointsVal = _mm_add_ps(avgPointsVal, _mm_and_ps(compareMask, dataPointsVal));
<a name="l00076"></a>00076 
<a name="l00077"></a>00077     <span class="comment">// Count the number of bins which do not exceed the mean amplitude</span>
<a name="l00078"></a>00078     vValidBinCount = _mm_add_ps(vValidBinCount, _mm_and_ps(compareMask, vOnesVector));
<a name="l00079"></a>00079   }
<a name="l00080"></a>00080 
<a name="l00081"></a>00081   <span class="comment">// Calculate the mean from the remaining data points</span>
<a name="l00082"></a>00082   _mm_store_ps(avgPointsVector, avgPointsVal);
<a name="l00083"></a>00083 
<a name="l00084"></a>00084   sumMean = 0.0;
<a name="l00085"></a>00085   sumMean += avgPointsVector[0];
<a name="l00086"></a>00086   sumMean += avgPointsVector[1];
<a name="l00087"></a>00087   sumMean += avgPointsVector[2];
<a name="l00088"></a>00088   sumMean += avgPointsVector[3];
<a name="l00089"></a>00089 
<a name="l00090"></a>00090   <span class="comment">// Calculate the number of valid bins from the remaning count</span>
<a name="l00091"></a>00091   <a class="code" href="volk__common_8h.html#af8ae70079c1927f7c46b6d1880473d17">__VOLK_ATTR_ALIGNED</a>(16) float validBinCountVector[4];
<a name="l00092"></a>00092   _mm_store_ps(validBinCountVector, vValidBinCount);
<a name="l00093"></a>00093 
<a name="l00094"></a>00094   <span class="keywordtype">float</span> validBinCount = 0;
<a name="l00095"></a>00095   validBinCount += validBinCountVector[0];
<a name="l00096"></a>00096   validBinCount += validBinCountVector[1];
<a name="l00097"></a>00097   validBinCount += validBinCountVector[2];
<a name="l00098"></a>00098   validBinCount += validBinCountVector[3];
<a name="l00099"></a>00099 
<a name="l00100"></a>00100   number = quarterPoints * 4;
<a name="l00101"></a>00101   for(;number &lt; num_points; number++){
<a name="l00102"></a>00102     <span class="keywordflow">if</span>(realDataPoints[number] &lt;= meanAmplitude){
<a name="l00103"></a>00103       sumMean += realDataPoints[number];
<a name="l00104"></a>00104       validBinCount += 1.0;
<a name="l00105"></a>00105     }
<a name="l00106"></a>00106   }
<a name="l00107"></a>00107 
<a name="l00108"></a>00108   <span class="keywordtype">float</span> localNoiseFloorAmplitude = 0;
<a name="l00109"></a>00109   <span class="keywordflow">if</span>(validBinCount &gt; 0.0){
<a name="l00110"></a>00110     localNoiseFloorAmplitude = sumMean / validBinCount;
<a name="l00111"></a>00111   }
<a name="l00112"></a>00112   <span class="keywordflow">else</span>{
<a name="l00113"></a>00113     localNoiseFloorAmplitude = meanAmplitude; <span class="comment">// For the odd case that all the amplitudes are equal...</span>
<a name="l00114"></a>00114   }
<a name="l00115"></a>00115 
<a name="l00116"></a>00116   *noiseFloorAmplitude = localNoiseFloorAmplitude;
<a name="l00117"></a>00117 }
<a name="l00118"></a>00118 <span class="preprocessor">#endif </span><span class="comment">/* LV_HAVE_SSE */</span>
<a name="l00119"></a>00119 
<a name="l00120"></a>00120 <span class="preprocessor">#ifdef LV_HAVE_GENERIC</span>
<a name="l00121"></a>00121 <span class="preprocessor"></span><span class="comment">/*!</span>
<a name="l00122"></a>00122 <span class="comment">  \brief Calculates the spectral noise floor of an input power spectrum</span>
<a name="l00123"></a>00123 <span class="comment"></span>
<a name="l00124"></a>00124 <span class="comment">  Calculates the spectral noise floor of an input power spectrum by determining the mean of the input power spectrum, then recalculating the mean excluding any power spectrum values that exceed the mean by the spectralExclusionValue (in dB).  Provides a rough estimation of the signal noise floor.</span>
<a name="l00125"></a>00125 <span class="comment"></span>
<a name="l00126"></a>00126 <span class="comment">  \param realDataPoints The input power spectrum</span>
<a name="l00127"></a>00127 <span class="comment">  \param num_points The number of data points in the input power spectrum vector</span>
<a name="l00128"></a>00128 <span class="comment">  \param spectralExclusionValue The number of dB above the noise floor that a data point must be to be excluded from the noise floor calculation - default value is 20</span>
<a name="l00129"></a>00129 <span class="comment">  \param noiseFloorAmplitude The noise floor of the input spectrum, in dB</span>
<a name="l00130"></a>00130 <span class="comment">*/</span>
<a name="l00131"></a>00131 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">void</span> volk_32f_s32f_calc_spectral_noise_floor_32f_a_generic(<span class="keywordtype">float</span>* noiseFloorAmplitude, <span class="keyword">const</span> <span class="keywordtype">float</span>* realDataPoints, <span class="keyword">const</span> <span class="keywordtype">float</span> spectralExclusionValue, <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> num_points){
<a name="l00132"></a>00132   <span class="keywordtype">float</span> sumMean = 0.0;
<a name="l00133"></a>00133   <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> number;
<a name="l00134"></a>00134   <span class="comment">// find the sum (for mean), etc</span>
<a name="l00135"></a>00135   <span class="keywordflow">for</span>(number = 0; number &lt; num_points; number++){
<a name="l00136"></a>00136     <span class="comment">// sum (for mean)</span>
<a name="l00137"></a>00137     sumMean += realDataPoints[number];
<a name="l00138"></a>00138   }
<a name="l00139"></a>00139 
<a name="l00140"></a>00140   <span class="comment">// calculate the spectral mean</span>
<a name="l00141"></a>00141   <span class="comment">// +20 because for the comparison below we only want to throw out bins</span>
<a name="l00142"></a>00142   <span class="comment">// that are significantly higher (and would, thus, affect the mean more)</span>
<a name="l00143"></a>00143   <span class="keyword">const</span> <span class="keywordtype">float</span> meanAmplitude = (sumMean / num_points) + spectralExclusionValue;
<a name="l00144"></a>00144 
<a name="l00145"></a>00145   <span class="comment">// now throw out any bins higher than the mean</span>
<a name="l00146"></a>00146   sumMean = 0.0;
<a name="l00147"></a>00147   <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> newNumDataPoints = num_points;
<a name="l00148"></a>00148   <span class="keywordflow">for</span>(number = 0; number &lt; num_points; number++){
<a name="l00149"></a>00149     <span class="keywordflow">if</span> (realDataPoints[number] &lt;= meanAmplitude)
<a name="l00150"></a>00150       sumMean += realDataPoints[number];
<a name="l00151"></a>00151     <span class="keywordflow">else</span>
<a name="l00152"></a>00152       newNumDataPoints--;
<a name="l00153"></a>00153   }
<a name="l00154"></a>00154 
<a name="l00155"></a>00155   <span class="keywordtype">float</span> localNoiseFloorAmplitude = 0.0;
<a name="l00156"></a>00156   <span class="keywordflow">if</span> (newNumDataPoints == 0)             <span class="comment">// in the odd case that all</span>
<a name="l00157"></a>00157     localNoiseFloorAmplitude = meanAmplitude; <span class="comment">// amplitudes are equal!</span>
<a name="l00158"></a>00158   <span class="keywordflow">else</span>
<a name="l00159"></a>00159     localNoiseFloorAmplitude = sumMean / ((float)newNumDataPoints);
<a name="l00160"></a>00160 
<a name="l00161"></a>00161   *noiseFloorAmplitude = localNoiseFloorAmplitude;
<a name="l00162"></a>00162 }
<a name="l00163"></a>00163 <span class="preprocessor">#endif </span><span class="comment">/* LV_HAVE_GENERIC */</span>
<a name="l00164"></a>00164 
<a name="l00165"></a>00165 
<a name="l00166"></a>00166 
<a name="l00167"></a>00167 
<a name="l00168"></a>00168 <span class="preprocessor">#endif </span><span class="comment">/* INCLUDED_volk_32f_s32f_calc_spectral_noise_floor_32f_a_H */</span>
</pre></div></div><!-- contents -->
</div>
  <div id="nav-path" class="navpath">
    <ul>
      <li class="navelem"><a class="el" href="volk__32f__s32f__calc__spectral__noise__floor__32f__a_8h.html">volk_32f_s32f_calc_spectral_noise_floor_32f_a.h</a>      </li>

    <li class="footer">Generated on Tue Jun 5 2012 16:56:54 for GNU Radio 3.6.1git-182-gab9a06f0 C++ API by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.6.1 </li>
   </ul>
 </div>


</body>
</html>
