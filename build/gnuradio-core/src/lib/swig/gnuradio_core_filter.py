# This file was automatically generated by SWIG (http://www.swig.org).
# Version 2.0.4
#
# Do not make changes to this file unless you know what you are doing--modify
# the SWIG interface file instead.



from sys import version_info
if version_info >= (2,6,0):
    def swig_import_helper():
        from os.path import dirname
        import imp
        fp = None
        try:
            fp, pathname, description = imp.find_module('_gnuradio_core_filter', [dirname(__file__)])
        except ImportError:
            import _gnuradio_core_filter
            return _gnuradio_core_filter
        if fp is not None:
            try:
                _mod = imp.load_module('_gnuradio_core_filter', fp, pathname, description)
            finally:
                fp.close()
            return _mod
    _gnuradio_core_filter = swig_import_helper()
    del swig_import_helper
else:
    import _gnuradio_core_filter
del version_info
try:
    _swig_property = property
except NameError:
    pass # Python < 2.2 doesn't have 'property'.
def _swig_setattr_nondynamic(self,class_type,name,value,static=1):
    if (name == "thisown"): return self.this.own(value)
    if (name == "this"):
        if type(value).__name__ == 'SwigPyObject':
            self.__dict__[name] = value
            return
    method = class_type.__swig_setmethods__.get(name,None)
    if method: return method(self,value)
    if (not static):
        self.__dict__[name] = value
    else:
        raise AttributeError("You cannot add attributes to %s" % self)

def _swig_setattr(self,class_type,name,value):
    return _swig_setattr_nondynamic(self,class_type,name,value,0)

def _swig_getattr(self,class_type,name):
    if (name == "thisown"): return self.this.own()
    method = class_type.__swig_getmethods__.get(name,None)
    if method: return method(self)
    raise AttributeError(name)

def _swig_repr(self):
    try: strthis = "proxy of " + self.this.__repr__()
    except: strthis = ""
    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)

try:
    _object = object
    _newclass = 1
except AttributeError:
    class _object : pass
    _newclass = 0


def _swig_setattr_nondynamic_method(set):
    def set_attr(self,name,value):
        if (name == "thisown"): return self.this.own(value)
        if hasattr(self,name) or (name == "this"):
            set(self,name,value)
        else:
            raise AttributeError("You cannot add attributes to %s" % self)
    return set_attr


try:
    import weakref
    weakref_proxy = weakref.proxy
except:
    weakref_proxy = lambda x: x


class SwigPyIterator(object):
    """Proxy of C++ swig::SwigPyIterator class"""
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _gnuradio_core_filter.delete_SwigPyIterator
    __del__ = lambda self : None;
    def value(self):
        """value(self) -> PyObject"""
        return _gnuradio_core_filter.SwigPyIterator_value(self)

    def incr(self, n = 1):
        """incr(self, size_t n = 1) -> SwigPyIterator"""
        return _gnuradio_core_filter.SwigPyIterator_incr(self, n)

    def decr(self, n = 1):
        """decr(self, size_t n = 1) -> SwigPyIterator"""
        return _gnuradio_core_filter.SwigPyIterator_decr(self, n)

    def distance(self, *args, **kwargs):
        """distance(self, SwigPyIterator x) -> ptrdiff_t"""
        return _gnuradio_core_filter.SwigPyIterator_distance(self, *args, **kwargs)

    def equal(self, *args, **kwargs):
        """equal(self, SwigPyIterator x) -> bool"""
        return _gnuradio_core_filter.SwigPyIterator_equal(self, *args, **kwargs)

    def copy(self):
        """copy(self) -> SwigPyIterator"""
        return _gnuradio_core_filter.SwigPyIterator_copy(self)

    def next(self):
        """next(self) -> PyObject"""
        return _gnuradio_core_filter.SwigPyIterator_next(self)

    def __next__(self):
        """__next__(self) -> PyObject"""
        return _gnuradio_core_filter.SwigPyIterator___next__(self)

    def previous(self):
        """previous(self) -> PyObject"""
        return _gnuradio_core_filter.SwigPyIterator_previous(self)

    def advance(self, *args, **kwargs):
        """advance(self, ptrdiff_t n) -> SwigPyIterator"""
        return _gnuradio_core_filter.SwigPyIterator_advance(self, *args, **kwargs)

    def __eq__(self, *args, **kwargs):
        """__eq__(self, SwigPyIterator x) -> bool"""
        return _gnuradio_core_filter.SwigPyIterator___eq__(self, *args, **kwargs)

    def __ne__(self, *args, **kwargs):
        """__ne__(self, SwigPyIterator x) -> bool"""
        return _gnuradio_core_filter.SwigPyIterator___ne__(self, *args, **kwargs)

    def __iadd__(self, *args, **kwargs):
        """__iadd__(self, ptrdiff_t n) -> SwigPyIterator"""
        return _gnuradio_core_filter.SwigPyIterator___iadd__(self, *args, **kwargs)

    def __isub__(self, *args, **kwargs):
        """__isub__(self, ptrdiff_t n) -> SwigPyIterator"""
        return _gnuradio_core_filter.SwigPyIterator___isub__(self, *args, **kwargs)

    def __add__(self, *args, **kwargs):
        """__add__(self, ptrdiff_t n) -> SwigPyIterator"""
        return _gnuradio_core_filter.SwigPyIterator___add__(self, *args, **kwargs)

    def __sub__(self, *args):
        """
        __sub__(self, ptrdiff_t n) -> SwigPyIterator
        __sub__(self, SwigPyIterator x) -> ptrdiff_t
        """
        return _gnuradio_core_filter.SwigPyIterator___sub__(self, *args)

    def __iter__(self): return self
SwigPyIterator_swigregister = _gnuradio_core_filter.SwigPyIterator_swigregister
SwigPyIterator_swigregister(SwigPyIterator)

class gr_iir_filter_ffd_sptr(object):
    """Proxy of C++ boost::shared_ptr<(gr_iir_filter_ffd)> class"""
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(self) -> gr_iir_filter_ffd_sptr
        __init__(self,  p) -> gr_iir_filter_ffd_sptr
        """
        this = _gnuradio_core_filter.new_gr_iir_filter_ffd_sptr(*args)
        try: self.this.append(this)
        except: self.this = this
    def __deref__(self):
        """__deref__(self)"""
        return _gnuradio_core_filter.gr_iir_filter_ffd_sptr___deref__(self)

    __swig_destroy__ = _gnuradio_core_filter.delete_gr_iir_filter_ffd_sptr
    __del__ = lambda self : None;
    def set_taps(self, *args, **kwargs):
        """set_taps(self, __dummy_5__ fftaps, __dummy_5__ fbtaps)"""
        return _gnuradio_core_filter.gr_iir_filter_ffd_sptr_set_taps(self, *args, **kwargs)

    def history(self):
        """history(self) -> unsigned int"""
        return _gnuradio_core_filter.gr_iir_filter_ffd_sptr_history(self)

    def output_multiple(self):
        """output_multiple(self) -> int"""
        return _gnuradio_core_filter.gr_iir_filter_ffd_sptr_output_multiple(self)

    def relative_rate(self):
        """relative_rate(self) -> double"""
        return _gnuradio_core_filter.gr_iir_filter_ffd_sptr_relative_rate(self)

    def start(self):
        """start(self) -> bool"""
        return _gnuradio_core_filter.gr_iir_filter_ffd_sptr_start(self)

    def stop(self):
        """stop(self) -> bool"""
        return _gnuradio_core_filter.gr_iir_filter_ffd_sptr_stop(self)

    def nitems_read(self, *args, **kwargs):
        """nitems_read(self, unsigned int which_input) -> uint64_t"""
        return _gnuradio_core_filter.gr_iir_filter_ffd_sptr_nitems_read(self, *args, **kwargs)

    def nitems_written(self, *args, **kwargs):
        """nitems_written(self, unsigned int which_output) -> uint64_t"""
        return _gnuradio_core_filter.gr_iir_filter_ffd_sptr_nitems_written(self, *args, **kwargs)

    def detail(self):
        """detail(self) -> gr_block_detail_sptr"""
        return _gnuradio_core_filter.gr_iir_filter_ffd_sptr_detail(self)

    def set_detail(self, *args, **kwargs):
        """set_detail(self, gr_block_detail_sptr detail)"""
        return _gnuradio_core_filter.gr_iir_filter_ffd_sptr_set_detail(self, *args, **kwargs)

    def name(self):
        """name(self) -> string"""
        return _gnuradio_core_filter.gr_iir_filter_ffd_sptr_name(self)

    def input_signature(self):
        """input_signature(self) -> gr_io_signature_sptr"""
        return _gnuradio_core_filter.gr_iir_filter_ffd_sptr_input_signature(self)

    def output_signature(self):
        """output_signature(self) -> gr_io_signature_sptr"""
        return _gnuradio_core_filter.gr_iir_filter_ffd_sptr_output_signature(self)

    def unique_id(self):
        """unique_id(self) -> long"""
        return _gnuradio_core_filter.gr_iir_filter_ffd_sptr_unique_id(self)

    def to_basic_block(self):
        """to_basic_block(self) -> gr_basic_block_sptr"""
        return _gnuradio_core_filter.gr_iir_filter_ffd_sptr_to_basic_block(self)

    def check_topology(self, *args, **kwargs):
        """check_topology(self, int ninputs, int noutputs) -> bool"""
        return _gnuradio_core_filter.gr_iir_filter_ffd_sptr_check_topology(self, *args, **kwargs)

gr_iir_filter_ffd_sptr_swigregister = _gnuradio_core_filter.gr_iir_filter_ffd_sptr_swigregister
gr_iir_filter_ffd_sptr_swigregister(gr_iir_filter_ffd_sptr)

gr_iir_filter_ffd_sptr.__repr__ = lambda self: "<gr_block %s (%d)>" % (self.name(), self.unique_id ())


def iir_filter_ffd(*args, **kwargs):
  """
    iir_filter_ffd(__dummy_5__ fftaps, __dummy_5__ fbtaps) -> gr_iir_filter_ffd_sptr

    IIR filter with float input, float output and double taps

    This filter uses the Direct Form I implementation, where  contains the feed-forward taps, and  the feedback ones.

    The input and output satisfy a difference equation of the form 

     
     y[n] - \sum_{k=1}^{M} a_k y[n-k] = \sum_{k=0}^{N} b_k x[n-k]
     

    with the corresponding rational system function 

     
     H(z) = \ frac{\sum_{k=0}^{M} b_k z^{-k}}{1 - \sum_{k=1}^{N} a_k z^{-k}}
     

    Note that some texts define the system function with a + in the denominator. If you're using that convention, you'll need to negate the feedback taps.
    """
  return _gnuradio_core_filter.iir_filter_ffd(*args, **kwargs)
class gr_single_pole_iir_filter_ff_sptr(object):
    """Proxy of C++ boost::shared_ptr<(gr_single_pole_iir_filter_ff)> class"""
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(self) -> gr_single_pole_iir_filter_ff_sptr
        __init__(self,  p) -> gr_single_pole_iir_filter_ff_sptr
        """
        this = _gnuradio_core_filter.new_gr_single_pole_iir_filter_ff_sptr(*args)
        try: self.this.append(this)
        except: self.this = this
    def __deref__(self):
        """__deref__(self)"""
        return _gnuradio_core_filter.gr_single_pole_iir_filter_ff_sptr___deref__(self)

    __swig_destroy__ = _gnuradio_core_filter.delete_gr_single_pole_iir_filter_ff_sptr
    __del__ = lambda self : None;
    def set_taps(self, *args, **kwargs):
        """set_taps(self, double alpha)"""
        return _gnuradio_core_filter.gr_single_pole_iir_filter_ff_sptr_set_taps(self, *args, **kwargs)

    def history(self):
        """history(self) -> unsigned int"""
        return _gnuradio_core_filter.gr_single_pole_iir_filter_ff_sptr_history(self)

    def output_multiple(self):
        """output_multiple(self) -> int"""
        return _gnuradio_core_filter.gr_single_pole_iir_filter_ff_sptr_output_multiple(self)

    def relative_rate(self):
        """relative_rate(self) -> double"""
        return _gnuradio_core_filter.gr_single_pole_iir_filter_ff_sptr_relative_rate(self)

    def start(self):
        """start(self) -> bool"""
        return _gnuradio_core_filter.gr_single_pole_iir_filter_ff_sptr_start(self)

    def stop(self):
        """stop(self) -> bool"""
        return _gnuradio_core_filter.gr_single_pole_iir_filter_ff_sptr_stop(self)

    def nitems_read(self, *args, **kwargs):
        """nitems_read(self, unsigned int which_input) -> uint64_t"""
        return _gnuradio_core_filter.gr_single_pole_iir_filter_ff_sptr_nitems_read(self, *args, **kwargs)

    def nitems_written(self, *args, **kwargs):
        """nitems_written(self, unsigned int which_output) -> uint64_t"""
        return _gnuradio_core_filter.gr_single_pole_iir_filter_ff_sptr_nitems_written(self, *args, **kwargs)

    def detail(self):
        """detail(self) -> gr_block_detail_sptr"""
        return _gnuradio_core_filter.gr_single_pole_iir_filter_ff_sptr_detail(self)

    def set_detail(self, *args, **kwargs):
        """set_detail(self, gr_block_detail_sptr detail)"""
        return _gnuradio_core_filter.gr_single_pole_iir_filter_ff_sptr_set_detail(self, *args, **kwargs)

    def name(self):
        """name(self) -> string"""
        return _gnuradio_core_filter.gr_single_pole_iir_filter_ff_sptr_name(self)

    def input_signature(self):
        """input_signature(self) -> gr_io_signature_sptr"""
        return _gnuradio_core_filter.gr_single_pole_iir_filter_ff_sptr_input_signature(self)

    def output_signature(self):
        """output_signature(self) -> gr_io_signature_sptr"""
        return _gnuradio_core_filter.gr_single_pole_iir_filter_ff_sptr_output_signature(self)

    def unique_id(self):
        """unique_id(self) -> long"""
        return _gnuradio_core_filter.gr_single_pole_iir_filter_ff_sptr_unique_id(self)

    def to_basic_block(self):
        """to_basic_block(self) -> gr_basic_block_sptr"""
        return _gnuradio_core_filter.gr_single_pole_iir_filter_ff_sptr_to_basic_block(self)

    def check_topology(self, *args, **kwargs):
        """check_topology(self, int ninputs, int noutputs) -> bool"""
        return _gnuradio_core_filter.gr_single_pole_iir_filter_ff_sptr_check_topology(self, *args, **kwargs)

gr_single_pole_iir_filter_ff_sptr_swigregister = _gnuradio_core_filter.gr_single_pole_iir_filter_ff_sptr_swigregister
gr_single_pole_iir_filter_ff_sptr_swigregister(gr_single_pole_iir_filter_ff_sptr)

gr_single_pole_iir_filter_ff_sptr.__repr__ = lambda self: "<gr_block %s (%d)>" % (self.name(), self.unique_id ())


def single_pole_iir_filter_ff(*args, **kwargs):
  """
    single_pole_iir_filter_ff(double alpha, unsigned int vlen = 1) -> gr_single_pole_iir_filter_ff_sptr

    single pole IIR filter with float input, float output

    The input and output satisfy a difference equation of the form

    y[n] - (1-alpha) y[n-1] = alpha x[n]
     

    with the corresponding rational system function 

     
    H(z) = \ frac{alpha}{1 - (1-alpha) z^{-1}}
     

    Note that some texts define the system function with a + in the denominator. If you're using that convention, you'll need to negate the feedback tap.
    """
  return _gnuradio_core_filter.single_pole_iir_filter_ff(*args, **kwargs)
class gr_single_pole_iir_filter_cc_sptr(object):
    """Proxy of C++ boost::shared_ptr<(gr_single_pole_iir_filter_cc)> class"""
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(self) -> gr_single_pole_iir_filter_cc_sptr
        __init__(self,  p) -> gr_single_pole_iir_filter_cc_sptr
        """
        this = _gnuradio_core_filter.new_gr_single_pole_iir_filter_cc_sptr(*args)
        try: self.this.append(this)
        except: self.this = this
    def __deref__(self):
        """__deref__(self)"""
        return _gnuradio_core_filter.gr_single_pole_iir_filter_cc_sptr___deref__(self)

    __swig_destroy__ = _gnuradio_core_filter.delete_gr_single_pole_iir_filter_cc_sptr
    __del__ = lambda self : None;
    def set_taps(self, *args, **kwargs):
        """set_taps(self, double alpha)"""
        return _gnuradio_core_filter.gr_single_pole_iir_filter_cc_sptr_set_taps(self, *args, **kwargs)

    def history(self):
        """history(self) -> unsigned int"""
        return _gnuradio_core_filter.gr_single_pole_iir_filter_cc_sptr_history(self)

    def output_multiple(self):
        """output_multiple(self) -> int"""
        return _gnuradio_core_filter.gr_single_pole_iir_filter_cc_sptr_output_multiple(self)

    def relative_rate(self):
        """relative_rate(self) -> double"""
        return _gnuradio_core_filter.gr_single_pole_iir_filter_cc_sptr_relative_rate(self)

    def start(self):
        """start(self) -> bool"""
        return _gnuradio_core_filter.gr_single_pole_iir_filter_cc_sptr_start(self)

    def stop(self):
        """stop(self) -> bool"""
        return _gnuradio_core_filter.gr_single_pole_iir_filter_cc_sptr_stop(self)

    def nitems_read(self, *args, **kwargs):
        """nitems_read(self, unsigned int which_input) -> uint64_t"""
        return _gnuradio_core_filter.gr_single_pole_iir_filter_cc_sptr_nitems_read(self, *args, **kwargs)

    def nitems_written(self, *args, **kwargs):
        """nitems_written(self, unsigned int which_output) -> uint64_t"""
        return _gnuradio_core_filter.gr_single_pole_iir_filter_cc_sptr_nitems_written(self, *args, **kwargs)

    def detail(self):
        """detail(self) -> gr_block_detail_sptr"""
        return _gnuradio_core_filter.gr_single_pole_iir_filter_cc_sptr_detail(self)

    def set_detail(self, *args, **kwargs):
        """set_detail(self, gr_block_detail_sptr detail)"""
        return _gnuradio_core_filter.gr_single_pole_iir_filter_cc_sptr_set_detail(self, *args, **kwargs)

    def name(self):
        """name(self) -> string"""
        return _gnuradio_core_filter.gr_single_pole_iir_filter_cc_sptr_name(self)

    def input_signature(self):
        """input_signature(self) -> gr_io_signature_sptr"""
        return _gnuradio_core_filter.gr_single_pole_iir_filter_cc_sptr_input_signature(self)

    def output_signature(self):
        """output_signature(self) -> gr_io_signature_sptr"""
        return _gnuradio_core_filter.gr_single_pole_iir_filter_cc_sptr_output_signature(self)

    def unique_id(self):
        """unique_id(self) -> long"""
        return _gnuradio_core_filter.gr_single_pole_iir_filter_cc_sptr_unique_id(self)

    def to_basic_block(self):
        """to_basic_block(self) -> gr_basic_block_sptr"""
        return _gnuradio_core_filter.gr_single_pole_iir_filter_cc_sptr_to_basic_block(self)

    def check_topology(self, *args, **kwargs):
        """check_topology(self, int ninputs, int noutputs) -> bool"""
        return _gnuradio_core_filter.gr_single_pole_iir_filter_cc_sptr_check_topology(self, *args, **kwargs)

gr_single_pole_iir_filter_cc_sptr_swigregister = _gnuradio_core_filter.gr_single_pole_iir_filter_cc_sptr_swigregister
gr_single_pole_iir_filter_cc_sptr_swigregister(gr_single_pole_iir_filter_cc_sptr)

gr_single_pole_iir_filter_cc_sptr.__repr__ = lambda self: "<gr_block %s (%d)>" % (self.name(), self.unique_id ())


def single_pole_iir_filter_cc(*args, **kwargs):
  """
    single_pole_iir_filter_cc(double alpha, unsigned int vlen = 1) -> gr_single_pole_iir_filter_cc_sptr

    single pole IIR filter with complex input, complex output

    The input and output satisfy a difference equation of the form

    y[n] - (1-alpha) y[n-1] = alpha x[n]
     

    with the corresponding rational system function 

     
     H(z) = \ frac{alpha}{1 - (1-alpha) z^{-1}}
     

    Note that some texts define the system function with a + in the denominator. If you're using that convention, you'll need to negate the feedback tap.
    """
  return _gnuradio_core_filter.single_pole_iir_filter_cc(*args, **kwargs)
class gr_hilbert_fc_sptr(object):
    """Proxy of C++ boost::shared_ptr<(gr_hilbert_fc)> class"""
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(self) -> gr_hilbert_fc_sptr
        __init__(self,  p) -> gr_hilbert_fc_sptr
        """
        this = _gnuradio_core_filter.new_gr_hilbert_fc_sptr(*args)
        try: self.this.append(this)
        except: self.this = this
    def __deref__(self):
        """__deref__(self)"""
        return _gnuradio_core_filter.gr_hilbert_fc_sptr___deref__(self)

    __swig_destroy__ = _gnuradio_core_filter.delete_gr_hilbert_fc_sptr
    __del__ = lambda self : None;
    def history(self):
        """history(self) -> unsigned int"""
        return _gnuradio_core_filter.gr_hilbert_fc_sptr_history(self)

    def output_multiple(self):
        """output_multiple(self) -> int"""
        return _gnuradio_core_filter.gr_hilbert_fc_sptr_output_multiple(self)

    def relative_rate(self):
        """relative_rate(self) -> double"""
        return _gnuradio_core_filter.gr_hilbert_fc_sptr_relative_rate(self)

    def start(self):
        """start(self) -> bool"""
        return _gnuradio_core_filter.gr_hilbert_fc_sptr_start(self)

    def stop(self):
        """stop(self) -> bool"""
        return _gnuradio_core_filter.gr_hilbert_fc_sptr_stop(self)

    def nitems_read(self, *args, **kwargs):
        """nitems_read(self, unsigned int which_input) -> uint64_t"""
        return _gnuradio_core_filter.gr_hilbert_fc_sptr_nitems_read(self, *args, **kwargs)

    def nitems_written(self, *args, **kwargs):
        """nitems_written(self, unsigned int which_output) -> uint64_t"""
        return _gnuradio_core_filter.gr_hilbert_fc_sptr_nitems_written(self, *args, **kwargs)

    def detail(self):
        """detail(self) -> gr_block_detail_sptr"""
        return _gnuradio_core_filter.gr_hilbert_fc_sptr_detail(self)

    def set_detail(self, *args, **kwargs):
        """set_detail(self, gr_block_detail_sptr detail)"""
        return _gnuradio_core_filter.gr_hilbert_fc_sptr_set_detail(self, *args, **kwargs)

    def name(self):
        """name(self) -> string"""
        return _gnuradio_core_filter.gr_hilbert_fc_sptr_name(self)

    def input_signature(self):
        """input_signature(self) -> gr_io_signature_sptr"""
        return _gnuradio_core_filter.gr_hilbert_fc_sptr_input_signature(self)

    def output_signature(self):
        """output_signature(self) -> gr_io_signature_sptr"""
        return _gnuradio_core_filter.gr_hilbert_fc_sptr_output_signature(self)

    def unique_id(self):
        """unique_id(self) -> long"""
        return _gnuradio_core_filter.gr_hilbert_fc_sptr_unique_id(self)

    def to_basic_block(self):
        """to_basic_block(self) -> gr_basic_block_sptr"""
        return _gnuradio_core_filter.gr_hilbert_fc_sptr_to_basic_block(self)

    def check_topology(self, *args, **kwargs):
        """check_topology(self, int ninputs, int noutputs) -> bool"""
        return _gnuradio_core_filter.gr_hilbert_fc_sptr_check_topology(self, *args, **kwargs)

gr_hilbert_fc_sptr_swigregister = _gnuradio_core_filter.gr_hilbert_fc_sptr_swigregister
gr_hilbert_fc_sptr_swigregister(gr_hilbert_fc_sptr)

gr_hilbert_fc_sptr.__repr__ = lambda self: "<gr_block %s (%d)>" % (self.name(), self.unique_id ())


def hilbert_fc(*args, **kwargs):
  """
    hilbert_fc(unsigned int ntaps) -> gr_hilbert_fc_sptr

    Hilbert transformer.

    real output is input appropriately delayed. imaginary output is hilbert filtered (90 degree phase shift) version of input.
    """
  return _gnuradio_core_filter.hilbert_fc(*args, **kwargs)
class gr_filter_delay_fc_sptr(object):
    """Proxy of C++ boost::shared_ptr<(gr_filter_delay_fc)> class"""
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(self) -> gr_filter_delay_fc_sptr
        __init__(self,  p) -> gr_filter_delay_fc_sptr
        """
        this = _gnuradio_core_filter.new_gr_filter_delay_fc_sptr(*args)
        try: self.this.append(this)
        except: self.this = this
    def __deref__(self):
        """__deref__(self)"""
        return _gnuradio_core_filter.gr_filter_delay_fc_sptr___deref__(self)

    __swig_destroy__ = _gnuradio_core_filter.delete_gr_filter_delay_fc_sptr
    __del__ = lambda self : None;
    def history(self):
        """history(self) -> unsigned int"""
        return _gnuradio_core_filter.gr_filter_delay_fc_sptr_history(self)

    def output_multiple(self):
        """output_multiple(self) -> int"""
        return _gnuradio_core_filter.gr_filter_delay_fc_sptr_output_multiple(self)

    def relative_rate(self):
        """relative_rate(self) -> double"""
        return _gnuradio_core_filter.gr_filter_delay_fc_sptr_relative_rate(self)

    def start(self):
        """start(self) -> bool"""
        return _gnuradio_core_filter.gr_filter_delay_fc_sptr_start(self)

    def stop(self):
        """stop(self) -> bool"""
        return _gnuradio_core_filter.gr_filter_delay_fc_sptr_stop(self)

    def nitems_read(self, *args, **kwargs):
        """nitems_read(self, unsigned int which_input) -> uint64_t"""
        return _gnuradio_core_filter.gr_filter_delay_fc_sptr_nitems_read(self, *args, **kwargs)

    def nitems_written(self, *args, **kwargs):
        """nitems_written(self, unsigned int which_output) -> uint64_t"""
        return _gnuradio_core_filter.gr_filter_delay_fc_sptr_nitems_written(self, *args, **kwargs)

    def detail(self):
        """detail(self) -> gr_block_detail_sptr"""
        return _gnuradio_core_filter.gr_filter_delay_fc_sptr_detail(self)

    def set_detail(self, *args, **kwargs):
        """set_detail(self, gr_block_detail_sptr detail)"""
        return _gnuradio_core_filter.gr_filter_delay_fc_sptr_set_detail(self, *args, **kwargs)

    def name(self):
        """name(self) -> string"""
        return _gnuradio_core_filter.gr_filter_delay_fc_sptr_name(self)

    def input_signature(self):
        """input_signature(self) -> gr_io_signature_sptr"""
        return _gnuradio_core_filter.gr_filter_delay_fc_sptr_input_signature(self)

    def output_signature(self):
        """output_signature(self) -> gr_io_signature_sptr"""
        return _gnuradio_core_filter.gr_filter_delay_fc_sptr_output_signature(self)

    def unique_id(self):
        """unique_id(self) -> long"""
        return _gnuradio_core_filter.gr_filter_delay_fc_sptr_unique_id(self)

    def to_basic_block(self):
        """to_basic_block(self) -> gr_basic_block_sptr"""
        return _gnuradio_core_filter.gr_filter_delay_fc_sptr_to_basic_block(self)

    def check_topology(self, *args, **kwargs):
        """check_topology(self, int ninputs, int noutputs) -> bool"""
        return _gnuradio_core_filter.gr_filter_delay_fc_sptr_check_topology(self, *args, **kwargs)

gr_filter_delay_fc_sptr_swigregister = _gnuradio_core_filter.gr_filter_delay_fc_sptr_swigregister
gr_filter_delay_fc_sptr_swigregister(gr_filter_delay_fc_sptr)

gr_filter_delay_fc_sptr.__repr__ = lambda self: "<gr_block %s (%d)>" % (self.name(), self.unique_id ())


def filter_delay_fc(*args, **kwargs):
  """
    filter_delay_fc(__dummy_4__ taps) -> gr_filter_delay_fc_sptr

    Filter-Delay Combination Block.

    The block takes one or two float stream and outputs a complex stream. If only one float stream is input, the real output is a delayed version of this input and the imaginary output is the filtered output. If two floats are connected to the input, then the real output is the delayed version of the first input, and the imaginary output is the filtered output. The delay in the real path accounts for the group delay introduced by the filter in the imaginary path. The filter taps needs to be calculated before initializing this block.
    """
  return _gnuradio_core_filter.filter_delay_fc(*args, **kwargs)
class gr_fft_filter_ccc_sptr(object):
    """Proxy of C++ boost::shared_ptr<(gr_fft_filter_ccc)> class"""
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(self) -> gr_fft_filter_ccc_sptr
        __init__(self,  p) -> gr_fft_filter_ccc_sptr
        """
        this = _gnuradio_core_filter.new_gr_fft_filter_ccc_sptr(*args)
        try: self.this.append(this)
        except: self.this = this
    def __deref__(self):
        """__deref__(self)"""
        return _gnuradio_core_filter.gr_fft_filter_ccc_sptr___deref__(self)

    __swig_destroy__ = _gnuradio_core_filter.delete_gr_fft_filter_ccc_sptr
    __del__ = lambda self : None;
    def set_taps(self, *args, **kwargs):
        """set_taps(self, std::vector<(gr_complex,std::allocator<(gr_complex)>)> taps)"""
        return _gnuradio_core_filter.gr_fft_filter_ccc_sptr_set_taps(self, *args, **kwargs)

    def taps(self):
        """taps(self) -> std::vector<(gr_complex,std::allocator<(gr_complex)>)>"""
        return _gnuradio_core_filter.gr_fft_filter_ccc_sptr_taps(self)

    def set_nthreads(self, *args, **kwargs):
        """
        set_nthreads(self, int n)

        Set number of threads to use.
        """
        return _gnuradio_core_filter.gr_fft_filter_ccc_sptr_set_nthreads(self, *args, **kwargs)

    def nthreads(self):
        """
        nthreads(self) -> int

        Get number of threads being used.
        """
        return _gnuradio_core_filter.gr_fft_filter_ccc_sptr_nthreads(self)

    def history(self):
        """history(self) -> unsigned int"""
        return _gnuradio_core_filter.gr_fft_filter_ccc_sptr_history(self)

    def output_multiple(self):
        """output_multiple(self) -> int"""
        return _gnuradio_core_filter.gr_fft_filter_ccc_sptr_output_multiple(self)

    def relative_rate(self):
        """relative_rate(self) -> double"""
        return _gnuradio_core_filter.gr_fft_filter_ccc_sptr_relative_rate(self)

    def start(self):
        """start(self) -> bool"""
        return _gnuradio_core_filter.gr_fft_filter_ccc_sptr_start(self)

    def stop(self):
        """stop(self) -> bool"""
        return _gnuradio_core_filter.gr_fft_filter_ccc_sptr_stop(self)

    def nitems_read(self, *args, **kwargs):
        """nitems_read(self, unsigned int which_input) -> uint64_t"""
        return _gnuradio_core_filter.gr_fft_filter_ccc_sptr_nitems_read(self, *args, **kwargs)

    def nitems_written(self, *args, **kwargs):
        """nitems_written(self, unsigned int which_output) -> uint64_t"""
        return _gnuradio_core_filter.gr_fft_filter_ccc_sptr_nitems_written(self, *args, **kwargs)

    def detail(self):
        """detail(self) -> gr_block_detail_sptr"""
        return _gnuradio_core_filter.gr_fft_filter_ccc_sptr_detail(self)

    def set_detail(self, *args, **kwargs):
        """set_detail(self, gr_block_detail_sptr detail)"""
        return _gnuradio_core_filter.gr_fft_filter_ccc_sptr_set_detail(self, *args, **kwargs)

    def name(self):
        """name(self) -> string"""
        return _gnuradio_core_filter.gr_fft_filter_ccc_sptr_name(self)

    def input_signature(self):
        """input_signature(self) -> gr_io_signature_sptr"""
        return _gnuradio_core_filter.gr_fft_filter_ccc_sptr_input_signature(self)

    def output_signature(self):
        """output_signature(self) -> gr_io_signature_sptr"""
        return _gnuradio_core_filter.gr_fft_filter_ccc_sptr_output_signature(self)

    def unique_id(self):
        """unique_id(self) -> long"""
        return _gnuradio_core_filter.gr_fft_filter_ccc_sptr_unique_id(self)

    def to_basic_block(self):
        """to_basic_block(self) -> gr_basic_block_sptr"""
        return _gnuradio_core_filter.gr_fft_filter_ccc_sptr_to_basic_block(self)

    def check_topology(self, *args, **kwargs):
        """check_topology(self, int ninputs, int noutputs) -> bool"""
        return _gnuradio_core_filter.gr_fft_filter_ccc_sptr_check_topology(self, *args, **kwargs)

gr_fft_filter_ccc_sptr_swigregister = _gnuradio_core_filter.gr_fft_filter_ccc_sptr_swigregister
gr_fft_filter_ccc_sptr_swigregister(gr_fft_filter_ccc_sptr)

gr_fft_filter_ccc_sptr.__repr__ = lambda self: "<gr_block %s (%d)>" % (self.name(), self.unique_id ())


def fft_filter_ccc(*args, **kwargs):
  """
    fft_filter_ccc(int decimation, std::vector<(gr_complex,std::allocator<(gr_complex)>)> taps, 
        int nthreads = 1) -> gr_fft_filter_ccc_sptr

    Fast FFT filter with gr_complex input, gr_complex output and gr_complex taps.
    """
  return _gnuradio_core_filter.fft_filter_ccc(*args, **kwargs)
class gr_fft_filter_fff_sptr(object):
    """Proxy of C++ boost::shared_ptr<(gr_fft_filter_fff)> class"""
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(self) -> gr_fft_filter_fff_sptr
        __init__(self,  p) -> gr_fft_filter_fff_sptr
        """
        this = _gnuradio_core_filter.new_gr_fft_filter_fff_sptr(*args)
        try: self.this.append(this)
        except: self.this = this
    def __deref__(self):
        """__deref__(self)"""
        return _gnuradio_core_filter.gr_fft_filter_fff_sptr___deref__(self)

    __swig_destroy__ = _gnuradio_core_filter.delete_gr_fft_filter_fff_sptr
    __del__ = lambda self : None;
    def set_taps(self, *args, **kwargs):
        """set_taps(self, __dummy_4__ taps)"""
        return _gnuradio_core_filter.gr_fft_filter_fff_sptr_set_taps(self, *args, **kwargs)

    def taps(self):
        """taps(self) -> __dummy_4__"""
        return _gnuradio_core_filter.gr_fft_filter_fff_sptr_taps(self)

    def set_nthreads(self, *args, **kwargs):
        """
        set_nthreads(self, int n)

        Set number of threads to use.
        """
        return _gnuradio_core_filter.gr_fft_filter_fff_sptr_set_nthreads(self, *args, **kwargs)

    def nthreads(self):
        """
        nthreads(self) -> int

        Get number of threads being used.
        """
        return _gnuradio_core_filter.gr_fft_filter_fff_sptr_nthreads(self)

    def history(self):
        """history(self) -> unsigned int"""
        return _gnuradio_core_filter.gr_fft_filter_fff_sptr_history(self)

    def output_multiple(self):
        """output_multiple(self) -> int"""
        return _gnuradio_core_filter.gr_fft_filter_fff_sptr_output_multiple(self)

    def relative_rate(self):
        """relative_rate(self) -> double"""
        return _gnuradio_core_filter.gr_fft_filter_fff_sptr_relative_rate(self)

    def start(self):
        """start(self) -> bool"""
        return _gnuradio_core_filter.gr_fft_filter_fff_sptr_start(self)

    def stop(self):
        """stop(self) -> bool"""
        return _gnuradio_core_filter.gr_fft_filter_fff_sptr_stop(self)

    def nitems_read(self, *args, **kwargs):
        """nitems_read(self, unsigned int which_input) -> uint64_t"""
        return _gnuradio_core_filter.gr_fft_filter_fff_sptr_nitems_read(self, *args, **kwargs)

    def nitems_written(self, *args, **kwargs):
        """nitems_written(self, unsigned int which_output) -> uint64_t"""
        return _gnuradio_core_filter.gr_fft_filter_fff_sptr_nitems_written(self, *args, **kwargs)

    def detail(self):
        """detail(self) -> gr_block_detail_sptr"""
        return _gnuradio_core_filter.gr_fft_filter_fff_sptr_detail(self)

    def set_detail(self, *args, **kwargs):
        """set_detail(self, gr_block_detail_sptr detail)"""
        return _gnuradio_core_filter.gr_fft_filter_fff_sptr_set_detail(self, *args, **kwargs)

    def name(self):
        """name(self) -> string"""
        return _gnuradio_core_filter.gr_fft_filter_fff_sptr_name(self)

    def input_signature(self):
        """input_signature(self) -> gr_io_signature_sptr"""
        return _gnuradio_core_filter.gr_fft_filter_fff_sptr_input_signature(self)

    def output_signature(self):
        """output_signature(self) -> gr_io_signature_sptr"""
        return _gnuradio_core_filter.gr_fft_filter_fff_sptr_output_signature(self)

    def unique_id(self):
        """unique_id(self) -> long"""
        return _gnuradio_core_filter.gr_fft_filter_fff_sptr_unique_id(self)

    def to_basic_block(self):
        """to_basic_block(self) -> gr_basic_block_sptr"""
        return _gnuradio_core_filter.gr_fft_filter_fff_sptr_to_basic_block(self)

    def check_topology(self, *args, **kwargs):
        """check_topology(self, int ninputs, int noutputs) -> bool"""
        return _gnuradio_core_filter.gr_fft_filter_fff_sptr_check_topology(self, *args, **kwargs)

gr_fft_filter_fff_sptr_swigregister = _gnuradio_core_filter.gr_fft_filter_fff_sptr_swigregister
gr_fft_filter_fff_sptr_swigregister(gr_fft_filter_fff_sptr)

gr_fft_filter_fff_sptr.__repr__ = lambda self: "<gr_block %s (%d)>" % (self.name(), self.unique_id ())


def fft_filter_fff(*args, **kwargs):
  """
    fft_filter_fff(int decimation, __dummy_4__ taps, int nthreads = 1) -> gr_fft_filter_fff_sptr

    Fast FFT filter with float input, float output and float taps.
    """
  return _gnuradio_core_filter.fft_filter_fff(*args, **kwargs)
class gr_fractional_interpolator_ff_sptr(object):
    """Proxy of C++ boost::shared_ptr<(gr_fractional_interpolator_ff)> class"""
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(self) -> gr_fractional_interpolator_ff_sptr
        __init__(self,  p) -> gr_fractional_interpolator_ff_sptr
        """
        this = _gnuradio_core_filter.new_gr_fractional_interpolator_ff_sptr(*args)
        try: self.this.append(this)
        except: self.this = this
    def __deref__(self):
        """__deref__(self)"""
        return _gnuradio_core_filter.gr_fractional_interpolator_ff_sptr___deref__(self)

    __swig_destroy__ = _gnuradio_core_filter.delete_gr_fractional_interpolator_ff_sptr
    __del__ = lambda self : None;
    def mu(self):
        """mu(self) -> float"""
        return _gnuradio_core_filter.gr_fractional_interpolator_ff_sptr_mu(self)

    def interp_ratio(self):
        """interp_ratio(self) -> float"""
        return _gnuradio_core_filter.gr_fractional_interpolator_ff_sptr_interp_ratio(self)

    def set_mu(self, *args, **kwargs):
        """set_mu(self, float mu)"""
        return _gnuradio_core_filter.gr_fractional_interpolator_ff_sptr_set_mu(self, *args, **kwargs)

    def set_interp_ratio(self, *args, **kwargs):
        """set_interp_ratio(self, float interp_ratio)"""
        return _gnuradio_core_filter.gr_fractional_interpolator_ff_sptr_set_interp_ratio(self, *args, **kwargs)

    def history(self):
        """history(self) -> unsigned int"""
        return _gnuradio_core_filter.gr_fractional_interpolator_ff_sptr_history(self)

    def output_multiple(self):
        """output_multiple(self) -> int"""
        return _gnuradio_core_filter.gr_fractional_interpolator_ff_sptr_output_multiple(self)

    def relative_rate(self):
        """relative_rate(self) -> double"""
        return _gnuradio_core_filter.gr_fractional_interpolator_ff_sptr_relative_rate(self)

    def start(self):
        """start(self) -> bool"""
        return _gnuradio_core_filter.gr_fractional_interpolator_ff_sptr_start(self)

    def stop(self):
        """stop(self) -> bool"""
        return _gnuradio_core_filter.gr_fractional_interpolator_ff_sptr_stop(self)

    def nitems_read(self, *args, **kwargs):
        """nitems_read(self, unsigned int which_input) -> uint64_t"""
        return _gnuradio_core_filter.gr_fractional_interpolator_ff_sptr_nitems_read(self, *args, **kwargs)

    def nitems_written(self, *args, **kwargs):
        """nitems_written(self, unsigned int which_output) -> uint64_t"""
        return _gnuradio_core_filter.gr_fractional_interpolator_ff_sptr_nitems_written(self, *args, **kwargs)

    def detail(self):
        """detail(self) -> gr_block_detail_sptr"""
        return _gnuradio_core_filter.gr_fractional_interpolator_ff_sptr_detail(self)

    def set_detail(self, *args, **kwargs):
        """set_detail(self, gr_block_detail_sptr detail)"""
        return _gnuradio_core_filter.gr_fractional_interpolator_ff_sptr_set_detail(self, *args, **kwargs)

    def name(self):
        """name(self) -> string"""
        return _gnuradio_core_filter.gr_fractional_interpolator_ff_sptr_name(self)

    def input_signature(self):
        """input_signature(self) -> gr_io_signature_sptr"""
        return _gnuradio_core_filter.gr_fractional_interpolator_ff_sptr_input_signature(self)

    def output_signature(self):
        """output_signature(self) -> gr_io_signature_sptr"""
        return _gnuradio_core_filter.gr_fractional_interpolator_ff_sptr_output_signature(self)

    def unique_id(self):
        """unique_id(self) -> long"""
        return _gnuradio_core_filter.gr_fractional_interpolator_ff_sptr_unique_id(self)

    def to_basic_block(self):
        """to_basic_block(self) -> gr_basic_block_sptr"""
        return _gnuradio_core_filter.gr_fractional_interpolator_ff_sptr_to_basic_block(self)

    def check_topology(self, *args, **kwargs):
        """check_topology(self, int ninputs, int noutputs) -> bool"""
        return _gnuradio_core_filter.gr_fractional_interpolator_ff_sptr_check_topology(self, *args, **kwargs)

gr_fractional_interpolator_ff_sptr_swigregister = _gnuradio_core_filter.gr_fractional_interpolator_ff_sptr_swigregister
gr_fractional_interpolator_ff_sptr_swigregister(gr_fractional_interpolator_ff_sptr)

gr_fractional_interpolator_ff_sptr.__repr__ = lambda self: "<gr_block %s (%d)>" % (self.name(), self.unique_id ())


def fractional_interpolator_ff(*args, **kwargs):
  """
    fractional_interpolator_ff(float phase_shift, float interp_ratio) -> gr_fractional_interpolator_ff_sptr

    Interpolating mmse filter with float input, float output.
    """
  return _gnuradio_core_filter.fractional_interpolator_ff(*args, **kwargs)
class gr_fractional_interpolator_cc_sptr(object):
    """Proxy of C++ boost::shared_ptr<(gr_fractional_interpolator_cc)> class"""
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(self) -> gr_fractional_interpolator_cc_sptr
        __init__(self,  p) -> gr_fractional_interpolator_cc_sptr
        """
        this = _gnuradio_core_filter.new_gr_fractional_interpolator_cc_sptr(*args)
        try: self.this.append(this)
        except: self.this = this
    def __deref__(self):
        """__deref__(self)"""
        return _gnuradio_core_filter.gr_fractional_interpolator_cc_sptr___deref__(self)

    __swig_destroy__ = _gnuradio_core_filter.delete_gr_fractional_interpolator_cc_sptr
    __del__ = lambda self : None;
    def mu(self):
        """mu(self) -> float"""
        return _gnuradio_core_filter.gr_fractional_interpolator_cc_sptr_mu(self)

    def interp_ratio(self):
        """interp_ratio(self) -> float"""
        return _gnuradio_core_filter.gr_fractional_interpolator_cc_sptr_interp_ratio(self)

    def set_mu(self, *args, **kwargs):
        """set_mu(self, float mu)"""
        return _gnuradio_core_filter.gr_fractional_interpolator_cc_sptr_set_mu(self, *args, **kwargs)

    def set_interp_ratio(self, *args, **kwargs):
        """set_interp_ratio(self, float interp_ratio)"""
        return _gnuradio_core_filter.gr_fractional_interpolator_cc_sptr_set_interp_ratio(self, *args, **kwargs)

    def history(self):
        """history(self) -> unsigned int"""
        return _gnuradio_core_filter.gr_fractional_interpolator_cc_sptr_history(self)

    def output_multiple(self):
        """output_multiple(self) -> int"""
        return _gnuradio_core_filter.gr_fractional_interpolator_cc_sptr_output_multiple(self)

    def relative_rate(self):
        """relative_rate(self) -> double"""
        return _gnuradio_core_filter.gr_fractional_interpolator_cc_sptr_relative_rate(self)

    def start(self):
        """start(self) -> bool"""
        return _gnuradio_core_filter.gr_fractional_interpolator_cc_sptr_start(self)

    def stop(self):
        """stop(self) -> bool"""
        return _gnuradio_core_filter.gr_fractional_interpolator_cc_sptr_stop(self)

    def nitems_read(self, *args, **kwargs):
        """nitems_read(self, unsigned int which_input) -> uint64_t"""
        return _gnuradio_core_filter.gr_fractional_interpolator_cc_sptr_nitems_read(self, *args, **kwargs)

    def nitems_written(self, *args, **kwargs):
        """nitems_written(self, unsigned int which_output) -> uint64_t"""
        return _gnuradio_core_filter.gr_fractional_interpolator_cc_sptr_nitems_written(self, *args, **kwargs)

    def detail(self):
        """detail(self) -> gr_block_detail_sptr"""
        return _gnuradio_core_filter.gr_fractional_interpolator_cc_sptr_detail(self)

    def set_detail(self, *args, **kwargs):
        """set_detail(self, gr_block_detail_sptr detail)"""
        return _gnuradio_core_filter.gr_fractional_interpolator_cc_sptr_set_detail(self, *args, **kwargs)

    def name(self):
        """name(self) -> string"""
        return _gnuradio_core_filter.gr_fractional_interpolator_cc_sptr_name(self)

    def input_signature(self):
        """input_signature(self) -> gr_io_signature_sptr"""
        return _gnuradio_core_filter.gr_fractional_interpolator_cc_sptr_input_signature(self)

    def output_signature(self):
        """output_signature(self) -> gr_io_signature_sptr"""
        return _gnuradio_core_filter.gr_fractional_interpolator_cc_sptr_output_signature(self)

    def unique_id(self):
        """unique_id(self) -> long"""
        return _gnuradio_core_filter.gr_fractional_interpolator_cc_sptr_unique_id(self)

    def to_basic_block(self):
        """to_basic_block(self) -> gr_basic_block_sptr"""
        return _gnuradio_core_filter.gr_fractional_interpolator_cc_sptr_to_basic_block(self)

    def check_topology(self, *args, **kwargs):
        """check_topology(self, int ninputs, int noutputs) -> bool"""
        return _gnuradio_core_filter.gr_fractional_interpolator_cc_sptr_check_topology(self, *args, **kwargs)

gr_fractional_interpolator_cc_sptr_swigregister = _gnuradio_core_filter.gr_fractional_interpolator_cc_sptr_swigregister
gr_fractional_interpolator_cc_sptr_swigregister(gr_fractional_interpolator_cc_sptr)

gr_fractional_interpolator_cc_sptr.__repr__ = lambda self: "<gr_block %s (%d)>" % (self.name(), self.unique_id ())


def fractional_interpolator_cc(*args, **kwargs):
  """
    fractional_interpolator_cc(float phase_shift, float interp_ratio) -> gr_fractional_interpolator_cc_sptr

    Interpolating mmse filter with gr_complex input, gr_complex output.
    """
  return _gnuradio_core_filter.fractional_interpolator_cc(*args, **kwargs)
class gr_goertzel_fc_sptr(object):
    """Proxy of C++ boost::shared_ptr<(gr_goertzel_fc)> class"""
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(self) -> gr_goertzel_fc_sptr
        __init__(self,  p) -> gr_goertzel_fc_sptr
        """
        this = _gnuradio_core_filter.new_gr_goertzel_fc_sptr(*args)
        try: self.this.append(this)
        except: self.this = this
    def __deref__(self):
        """__deref__(self)"""
        return _gnuradio_core_filter.gr_goertzel_fc_sptr___deref__(self)

    __swig_destroy__ = _gnuradio_core_filter.delete_gr_goertzel_fc_sptr
    __del__ = lambda self : None;
    def set_freq(self, *args, **kwargs):
        """set_freq(self, float freq)"""
        return _gnuradio_core_filter.gr_goertzel_fc_sptr_set_freq(self, *args, **kwargs)

    def set_rate(self, *args, **kwargs):
        """set_rate(self, int rate)"""
        return _gnuradio_core_filter.gr_goertzel_fc_sptr_set_rate(self, *args, **kwargs)

    def history(self):
        """history(self) -> unsigned int"""
        return _gnuradio_core_filter.gr_goertzel_fc_sptr_history(self)

    def output_multiple(self):
        """output_multiple(self) -> int"""
        return _gnuradio_core_filter.gr_goertzel_fc_sptr_output_multiple(self)

    def relative_rate(self):
        """relative_rate(self) -> double"""
        return _gnuradio_core_filter.gr_goertzel_fc_sptr_relative_rate(self)

    def start(self):
        """start(self) -> bool"""
        return _gnuradio_core_filter.gr_goertzel_fc_sptr_start(self)

    def stop(self):
        """stop(self) -> bool"""
        return _gnuradio_core_filter.gr_goertzel_fc_sptr_stop(self)

    def nitems_read(self, *args, **kwargs):
        """nitems_read(self, unsigned int which_input) -> uint64_t"""
        return _gnuradio_core_filter.gr_goertzel_fc_sptr_nitems_read(self, *args, **kwargs)

    def nitems_written(self, *args, **kwargs):
        """nitems_written(self, unsigned int which_output) -> uint64_t"""
        return _gnuradio_core_filter.gr_goertzel_fc_sptr_nitems_written(self, *args, **kwargs)

    def detail(self):
        """detail(self) -> gr_block_detail_sptr"""
        return _gnuradio_core_filter.gr_goertzel_fc_sptr_detail(self)

    def set_detail(self, *args, **kwargs):
        """set_detail(self, gr_block_detail_sptr detail)"""
        return _gnuradio_core_filter.gr_goertzel_fc_sptr_set_detail(self, *args, **kwargs)

    def name(self):
        """name(self) -> string"""
        return _gnuradio_core_filter.gr_goertzel_fc_sptr_name(self)

    def input_signature(self):
        """input_signature(self) -> gr_io_signature_sptr"""
        return _gnuradio_core_filter.gr_goertzel_fc_sptr_input_signature(self)

    def output_signature(self):
        """output_signature(self) -> gr_io_signature_sptr"""
        return _gnuradio_core_filter.gr_goertzel_fc_sptr_output_signature(self)

    def unique_id(self):
        """unique_id(self) -> long"""
        return _gnuradio_core_filter.gr_goertzel_fc_sptr_unique_id(self)

    def to_basic_block(self):
        """to_basic_block(self) -> gr_basic_block_sptr"""
        return _gnuradio_core_filter.gr_goertzel_fc_sptr_to_basic_block(self)

    def check_topology(self, *args, **kwargs):
        """check_topology(self, int ninputs, int noutputs) -> bool"""
        return _gnuradio_core_filter.gr_goertzel_fc_sptr_check_topology(self, *args, **kwargs)

gr_goertzel_fc_sptr_swigregister = _gnuradio_core_filter.gr_goertzel_fc_sptr_swigregister
gr_goertzel_fc_sptr_swigregister(gr_goertzel_fc_sptr)

gr_goertzel_fc_sptr.__repr__ = lambda self: "<gr_block %s (%d)>" % (self.name(), self.unique_id ())


def goertzel_fc(*args, **kwargs):
  """
    goertzel_fc(int rate, int len, float freq) -> gr_goertzel_fc_sptr

    Goertzel single-bin DFT calculation.
    """
  return _gnuradio_core_filter.goertzel_fc(*args, **kwargs)
class gr_pfb_channelizer_ccf_sptr(object):
    """Proxy of C++ boost::shared_ptr<(gr_pfb_channelizer_ccf)> class"""
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(self) -> gr_pfb_channelizer_ccf_sptr
        __init__(self,  p) -> gr_pfb_channelizer_ccf_sptr
        """
        this = _gnuradio_core_filter.new_gr_pfb_channelizer_ccf_sptr(*args)
        try: self.this.append(this)
        except: self.this = this
    def __deref__(self):
        """__deref__(self)"""
        return _gnuradio_core_filter.gr_pfb_channelizer_ccf_sptr___deref__(self)

    __swig_destroy__ = _gnuradio_core_filter.delete_gr_pfb_channelizer_ccf_sptr
    __del__ = lambda self : None;
    def set_taps(self, *args, **kwargs):
        """
        set_taps(self, __dummy_4__ taps)

        Resets the filterbank's filter taps with the new prototype filter
        """
        return _gnuradio_core_filter.gr_pfb_channelizer_ccf_sptr_set_taps(self, *args, **kwargs)

    def print_taps(self):
        """
        print_taps(self)

        Print all of the filterbank taps to screen.
        """
        return _gnuradio_core_filter.gr_pfb_channelizer_ccf_sptr_print_taps(self)

    def taps(self):
        """
        taps(self) -> __dummy_11__

        Return a vector<vector<>> of the filterbank taps
        """
        return _gnuradio_core_filter.gr_pfb_channelizer_ccf_sptr_taps(self)

    def set_channel_map(self, *args, **kwargs):
        """
        set_channel_map(self, __dummy_3__ map)

        Set the channel map. Channels are numbers as:

        N/2+1 | ... | N-1 | 0 | 1 | 2 | ... | N/2 <------------------- 0 --------------------> freq

        So output stream 0 comes from channel 0, etc. Setting a new channel map allows the user to specify which channel in frequency he/she wants to got to which output stream.

        The map should have the same number of elements as the number of output connections from the block. The minimum value of the map is 0 (for the 0th channel) and the maximum number is N-1 where N is the number of channels.

        We specify M as the number of output connections made where M <= N, so only M out of N channels are driven to an output stream. The number of items in the channel map should be at least M long. If there are more channels specified, any value in the map over M-1 will be ignored. If the size of the map is less than M the behavior is unknown (we don't wish to check every entry into the work function).

        This means that if the channelizer is splitting the signal up into N channels but only M channels are specified in the map (where M <= N), then M output streams must be connected and the map and the channel numbers used must be less than N-1. Output channel number can be reused, too. By default, the map is [0...M-1] with M = N.
        """
        return _gnuradio_core_filter.gr_pfb_channelizer_ccf_sptr_set_channel_map(self, *args, **kwargs)

    def channel_map(self):
        """
        channel_map(self) -> __dummy_3__

        Gets the current channel map.
        """
        return _gnuradio_core_filter.gr_pfb_channelizer_ccf_sptr_channel_map(self)

    def history(self):
        """history(self) -> unsigned int"""
        return _gnuradio_core_filter.gr_pfb_channelizer_ccf_sptr_history(self)

    def output_multiple(self):
        """output_multiple(self) -> int"""
        return _gnuradio_core_filter.gr_pfb_channelizer_ccf_sptr_output_multiple(self)

    def relative_rate(self):
        """relative_rate(self) -> double"""
        return _gnuradio_core_filter.gr_pfb_channelizer_ccf_sptr_relative_rate(self)

    def start(self):
        """start(self) -> bool"""
        return _gnuradio_core_filter.gr_pfb_channelizer_ccf_sptr_start(self)

    def stop(self):
        """stop(self) -> bool"""
        return _gnuradio_core_filter.gr_pfb_channelizer_ccf_sptr_stop(self)

    def nitems_read(self, *args, **kwargs):
        """nitems_read(self, unsigned int which_input) -> uint64_t"""
        return _gnuradio_core_filter.gr_pfb_channelizer_ccf_sptr_nitems_read(self, *args, **kwargs)

    def nitems_written(self, *args, **kwargs):
        """nitems_written(self, unsigned int which_output) -> uint64_t"""
        return _gnuradio_core_filter.gr_pfb_channelizer_ccf_sptr_nitems_written(self, *args, **kwargs)

    def detail(self):
        """detail(self) -> gr_block_detail_sptr"""
        return _gnuradio_core_filter.gr_pfb_channelizer_ccf_sptr_detail(self)

    def set_detail(self, *args, **kwargs):
        """set_detail(self, gr_block_detail_sptr detail)"""
        return _gnuradio_core_filter.gr_pfb_channelizer_ccf_sptr_set_detail(self, *args, **kwargs)

    def name(self):
        """name(self) -> string"""
        return _gnuradio_core_filter.gr_pfb_channelizer_ccf_sptr_name(self)

    def input_signature(self):
        """input_signature(self) -> gr_io_signature_sptr"""
        return _gnuradio_core_filter.gr_pfb_channelizer_ccf_sptr_input_signature(self)

    def output_signature(self):
        """output_signature(self) -> gr_io_signature_sptr"""
        return _gnuradio_core_filter.gr_pfb_channelizer_ccf_sptr_output_signature(self)

    def unique_id(self):
        """unique_id(self) -> long"""
        return _gnuradio_core_filter.gr_pfb_channelizer_ccf_sptr_unique_id(self)

    def to_basic_block(self):
        """to_basic_block(self) -> gr_basic_block_sptr"""
        return _gnuradio_core_filter.gr_pfb_channelizer_ccf_sptr_to_basic_block(self)

    def check_topology(self, *args, **kwargs):
        """check_topology(self, int ninputs, int noutputs) -> bool"""
        return _gnuradio_core_filter.gr_pfb_channelizer_ccf_sptr_check_topology(self, *args, **kwargs)

gr_pfb_channelizer_ccf_sptr_swigregister = _gnuradio_core_filter.gr_pfb_channelizer_ccf_sptr_swigregister
gr_pfb_channelizer_ccf_sptr_swigregister(gr_pfb_channelizer_ccf_sptr)

gr_pfb_channelizer_ccf_sptr.__repr__ = lambda self: "<gr_block %s (%d)>" % (self.name(), self.unique_id ())


def pfb_channelizer_ccf(*args, **kwargs):
  """
    pfb_channelizer_ccf(unsigned int numchans, __dummy_4__ taps, float oversample_rate = 1) -> gr_pfb_channelizer_ccf_sptr

    Polyphase filterbank channelizer with gr_complex input, gr_complex output and float taps.

    This block takes in complex inputs and channelizes it to  channels of equal bandwidth. Each of the resulting channels is decimated to the new rate that is the input sampling rate  divided by the number of channels, .

    The PFB channelizer code takes the taps generated above and builds a set of filters. The set contains  number of filters and each filter contains ceil(taps.size()/decim) number of taps. Each tap from the filter prototype is sequentially inserted into the next filter. When all of the input taps are used, the remaining filters in the filterbank are filled out with 0's to make sure each filter has the same number of taps.

    Each filter operates using the gr_fir filter classs of GNU Radio, which takes the input stream at  and performs the inner product calculation to  where  is the number of filter taps. To efficiently handle this in the GNU Radio structure, each filter input must come from its own input stream. So the channelizer must be provided with  streams where the input stream has been deinterleaved. This is most easily done using the gr_stream_to_streams block.

    The output is then produced as a vector, where index  in the vector is the next sample from the th channel. This is most easily handled by sending the output to a gr_vector_to_streams block to handle the conversion and passing  streams out.

    The input and output formatting is done using a hier_block2 called pfb_channelizer_ccf. This can take in a single stream and outputs  streams based on the behavior described above.

    The filter's taps should be based on the input sampling rate.

    For example, using the GNU Radio's firdes utility to building filters, we build a low-pass filter with a sampling rate of , a 3-dB bandwidth of  and a transition bandwidth of . We can also specify the out-of-band attenuation to use, , and the filter window function (a Blackman-harris window in this case). The first input is the gain of the filter, which we specify here as unity.



    The filter output can also be overs ampled. The over sampling rate is the ratio of the the actual output sampling rate to the normal output sampling rate. It must be rationally related to the number of channels as N/i for i in [1,N], which gives an outputsample rate of [fs/N, fs] where fs is the input sample rate and N is the number of channels.

    For example, for 6 channels with fs = 6000 Hz, the normal rate is 6000/6 = 1000 Hz. Allowable oversampling rates are 6/6, 6/5, 6/4, 6/3, 6/2, and 6/1 where the output sample rate of a 6/1 oversample ratio is 6000 Hz, or 6 times the normal 1000 Hz. A rate of 6/5 = 1.2, so the output rate would be 1200 Hz.

    The theory behind this block can be found in Chapter 6 of the following book.

    Build the polyphase filterbank decimator. 
    For example, for 6 channels with fs = 6000 Hz, the normal rate is 6000/6 = 1000 Hz. Allowable oversampling rates are 6/6, 6/5, 6/4, 6/3, 6/2, and 6/1 where the output sample rate of a 6/1 oversample ratio is 6000 Hz, or 6 times the normal 1000 Hz.
    """
  return _gnuradio_core_filter.pfb_channelizer_ccf(*args, **kwargs)
class gr_pfb_synthesizer_ccf_sptr(object):
    """Proxy of C++ boost::shared_ptr<(gr_pfb_synthesizer_ccf)> class"""
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(self) -> gr_pfb_synthesizer_ccf_sptr
        __init__(self,  p) -> gr_pfb_synthesizer_ccf_sptr
        """
        this = _gnuradio_core_filter.new_gr_pfb_synthesizer_ccf_sptr(*args)
        try: self.this.append(this)
        except: self.this = this
    def __deref__(self):
        """__deref__(self)"""
        return _gnuradio_core_filter.gr_pfb_synthesizer_ccf_sptr___deref__(self)

    __swig_destroy__ = _gnuradio_core_filter.delete_gr_pfb_synthesizer_ccf_sptr
    __del__ = lambda self : None;
    def set_taps(self, *args, **kwargs):
        """
        set_taps(self, __dummy_4__ taps)

        Resets the filterbank's filter taps with the new prototype filter
        """
        return _gnuradio_core_filter.gr_pfb_synthesizer_ccf_sptr_set_taps(self, *args, **kwargs)

    def print_taps(self):
        """
        print_taps(self)

        Print all of the filterbank taps to screen.
        """
        return _gnuradio_core_filter.gr_pfb_synthesizer_ccf_sptr_print_taps(self)

    def taps(self):
        """
        taps(self) -> __dummy_11__

        Return a vector<vector<>> of the filterbank taps
        """
        return _gnuradio_core_filter.gr_pfb_synthesizer_ccf_sptr_taps(self)

    def set_channel_map(self, *args, **kwargs):
        """
        set_channel_map(self, __dummy_3__ map)

        Set the channel map. Channels are numbers as: N/2+1 | ... | N-1 | 0 | 1 | 2 | ... | N/2 <------------------- 0 --------------------> freq

        So input stream 0 goes to channel 0, etc. Setting a new channel map allows the user to specify where in frequency he/she wants the input stream to go. This is especially useful to avoid putting signals into the channels on the edge of the spectrum which can either wrap around (in the case of odd number of channels) and be affected by filter rolloff in the transmitter.

        The map must be at least the number of streams being sent to the block. Less and the algorithm will not have enough data to properly setup the buffers. Any more channels specified will be ignored.
        """
        return _gnuradio_core_filter.gr_pfb_synthesizer_ccf_sptr_set_channel_map(self, *args, **kwargs)

    def channel_map(self):
        """
        channel_map(self) -> __dummy_3__

        Gets the current channel map.
        """
        return _gnuradio_core_filter.gr_pfb_synthesizer_ccf_sptr_channel_map(self)

    def history(self):
        """history(self) -> unsigned int"""
        return _gnuradio_core_filter.gr_pfb_synthesizer_ccf_sptr_history(self)

    def output_multiple(self):
        """output_multiple(self) -> int"""
        return _gnuradio_core_filter.gr_pfb_synthesizer_ccf_sptr_output_multiple(self)

    def relative_rate(self):
        """relative_rate(self) -> double"""
        return _gnuradio_core_filter.gr_pfb_synthesizer_ccf_sptr_relative_rate(self)

    def start(self):
        """start(self) -> bool"""
        return _gnuradio_core_filter.gr_pfb_synthesizer_ccf_sptr_start(self)

    def stop(self):
        """stop(self) -> bool"""
        return _gnuradio_core_filter.gr_pfb_synthesizer_ccf_sptr_stop(self)

    def nitems_read(self, *args, **kwargs):
        """nitems_read(self, unsigned int which_input) -> uint64_t"""
        return _gnuradio_core_filter.gr_pfb_synthesizer_ccf_sptr_nitems_read(self, *args, **kwargs)

    def nitems_written(self, *args, **kwargs):
        """nitems_written(self, unsigned int which_output) -> uint64_t"""
        return _gnuradio_core_filter.gr_pfb_synthesizer_ccf_sptr_nitems_written(self, *args, **kwargs)

    def detail(self):
        """detail(self) -> gr_block_detail_sptr"""
        return _gnuradio_core_filter.gr_pfb_synthesizer_ccf_sptr_detail(self)

    def set_detail(self, *args, **kwargs):
        """set_detail(self, gr_block_detail_sptr detail)"""
        return _gnuradio_core_filter.gr_pfb_synthesizer_ccf_sptr_set_detail(self, *args, **kwargs)

    def name(self):
        """name(self) -> string"""
        return _gnuradio_core_filter.gr_pfb_synthesizer_ccf_sptr_name(self)

    def input_signature(self):
        """input_signature(self) -> gr_io_signature_sptr"""
        return _gnuradio_core_filter.gr_pfb_synthesizer_ccf_sptr_input_signature(self)

    def output_signature(self):
        """output_signature(self) -> gr_io_signature_sptr"""
        return _gnuradio_core_filter.gr_pfb_synthesizer_ccf_sptr_output_signature(self)

    def unique_id(self):
        """unique_id(self) -> long"""
        return _gnuradio_core_filter.gr_pfb_synthesizer_ccf_sptr_unique_id(self)

    def to_basic_block(self):
        """to_basic_block(self) -> gr_basic_block_sptr"""
        return _gnuradio_core_filter.gr_pfb_synthesizer_ccf_sptr_to_basic_block(self)

    def check_topology(self, *args, **kwargs):
        """check_topology(self, int ninputs, int noutputs) -> bool"""
        return _gnuradio_core_filter.gr_pfb_synthesizer_ccf_sptr_check_topology(self, *args, **kwargs)

gr_pfb_synthesizer_ccf_sptr_swigregister = _gnuradio_core_filter.gr_pfb_synthesizer_ccf_sptr_swigregister
gr_pfb_synthesizer_ccf_sptr_swigregister(gr_pfb_synthesizer_ccf_sptr)

gr_pfb_synthesizer_ccf_sptr.__repr__ = lambda self: "<gr_block %s (%d)>" % (self.name(), self.unique_id ())


def pfb_synthesizer_ccf(*args, **kwargs):
  """
    pfb_synthesizer_ccf(unsigned int numchans, __dummy_4__ taps, bool twox = False) -> gr_pfb_synthesizer_ccf_sptr

    Polyphase synthesis filterbank with gr_complex input, gr_complex output and float taps.

    Build the polyphase synthesis filterbank.
    """
  return _gnuradio_core_filter.pfb_synthesizer_ccf(*args, **kwargs)
class gr_pfb_decimator_ccf_sptr(object):
    """Proxy of C++ boost::shared_ptr<(gr_pfb_decimator_ccf)> class"""
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(self) -> gr_pfb_decimator_ccf_sptr
        __init__(self,  p) -> gr_pfb_decimator_ccf_sptr
        """
        this = _gnuradio_core_filter.new_gr_pfb_decimator_ccf_sptr(*args)
        try: self.this.append(this)
        except: self.this = this
    def __deref__(self):
        """__deref__(self)"""
        return _gnuradio_core_filter.gr_pfb_decimator_ccf_sptr___deref__(self)

    __swig_destroy__ = _gnuradio_core_filter.delete_gr_pfb_decimator_ccf_sptr
    __del__ = lambda self : None;
    def set_taps(self, *args, **kwargs):
        """
        set_taps(self, __dummy_4__ taps)

        Resets the filterbank's filter taps with the new prototype filter
        """
        return _gnuradio_core_filter.gr_pfb_decimator_ccf_sptr_set_taps(self, *args, **kwargs)

    def history(self):
        """history(self) -> unsigned int"""
        return _gnuradio_core_filter.gr_pfb_decimator_ccf_sptr_history(self)

    def output_multiple(self):
        """output_multiple(self) -> int"""
        return _gnuradio_core_filter.gr_pfb_decimator_ccf_sptr_output_multiple(self)

    def relative_rate(self):
        """relative_rate(self) -> double"""
        return _gnuradio_core_filter.gr_pfb_decimator_ccf_sptr_relative_rate(self)

    def start(self):
        """start(self) -> bool"""
        return _gnuradio_core_filter.gr_pfb_decimator_ccf_sptr_start(self)

    def stop(self):
        """stop(self) -> bool"""
        return _gnuradio_core_filter.gr_pfb_decimator_ccf_sptr_stop(self)

    def nitems_read(self, *args, **kwargs):
        """nitems_read(self, unsigned int which_input) -> uint64_t"""
        return _gnuradio_core_filter.gr_pfb_decimator_ccf_sptr_nitems_read(self, *args, **kwargs)

    def nitems_written(self, *args, **kwargs):
        """nitems_written(self, unsigned int which_output) -> uint64_t"""
        return _gnuradio_core_filter.gr_pfb_decimator_ccf_sptr_nitems_written(self, *args, **kwargs)

    def detail(self):
        """detail(self) -> gr_block_detail_sptr"""
        return _gnuradio_core_filter.gr_pfb_decimator_ccf_sptr_detail(self)

    def set_detail(self, *args, **kwargs):
        """set_detail(self, gr_block_detail_sptr detail)"""
        return _gnuradio_core_filter.gr_pfb_decimator_ccf_sptr_set_detail(self, *args, **kwargs)

    def name(self):
        """name(self) -> string"""
        return _gnuradio_core_filter.gr_pfb_decimator_ccf_sptr_name(self)

    def input_signature(self):
        """input_signature(self) -> gr_io_signature_sptr"""
        return _gnuradio_core_filter.gr_pfb_decimator_ccf_sptr_input_signature(self)

    def output_signature(self):
        """output_signature(self) -> gr_io_signature_sptr"""
        return _gnuradio_core_filter.gr_pfb_decimator_ccf_sptr_output_signature(self)

    def unique_id(self):
        """unique_id(self) -> long"""
        return _gnuradio_core_filter.gr_pfb_decimator_ccf_sptr_unique_id(self)

    def to_basic_block(self):
        """to_basic_block(self) -> gr_basic_block_sptr"""
        return _gnuradio_core_filter.gr_pfb_decimator_ccf_sptr_to_basic_block(self)

    def check_topology(self, *args, **kwargs):
        """check_topology(self, int ninputs, int noutputs) -> bool"""
        return _gnuradio_core_filter.gr_pfb_decimator_ccf_sptr_check_topology(self, *args, **kwargs)

gr_pfb_decimator_ccf_sptr_swigregister = _gnuradio_core_filter.gr_pfb_decimator_ccf_sptr_swigregister
gr_pfb_decimator_ccf_sptr_swigregister(gr_pfb_decimator_ccf_sptr)

gr_pfb_decimator_ccf_sptr.__repr__ = lambda self: "<gr_block %s (%d)>" % (self.name(), self.unique_id ())


def pfb_decimator_ccf(*args, **kwargs):
  """
    pfb_decimator_ccf(unsigned int decim, __dummy_4__ taps, unsigned int channel) -> gr_pfb_decimator_ccf_sptr

    Polyphase filterbank bandpass decimator with gr_complex input, gr_complex output and float taps.

    This block takes in a signal stream and performs interger down- sampling (decimation) with a polyphase filterbank. The first input is the integer specifying how much to decimate by. The second input is a vector (Python list) of floating-point taps of the prototype filter. The third input specifies the channel to extract. By default, the zeroth channel is used, which is the baseband channel (first Nyquist zone).

    The  parameter specifies which channel to use since this class is capable of bandpass decimation. Given a complex input stream at a sampling rate of  and a decimation rate of , the input frequency domain is split into  channels that represent the Nyquist zones. Using the polyphase filterbank, we can select any one of these channels to decimate.

    The output signal will be the basebanded and decimated signal from that channel. This concept is very similar to the PFB channelizer (see gr_pfb_channelizer_ccf) where only a single channel is extracted at a time.

    The filter's taps should be based on the sampling rate before decimation.

    For example, using the GNU Radio's firdes utility to building filters, we build a low-pass filter with a sampling rate of , a 3-dB bandwidth of  and a transition bandwidth of . We can also specify the out-of-band attenuation to use, , and the filter window function (a Blackman-harris window in this case). The first input is the gain of the filter, which we specify here as unity.



    The PFB decimator code takes the taps generated above and builds a set of filters. The set contains  number of filters and each filter contains ceil(taps.size()/decim) number of taps. Each tap from the filter prototype is sequentially inserted into the next filter. When all of the input taps are used, the remaining filters in the filterbank are filled out with 0's to make sure each filter has the same number of taps.

    The theory behind this block can be found in Chapter 6 of the following book.

    Build the polyphase filterbank decimator.
    """
  return _gnuradio_core_filter.pfb_decimator_ccf(*args, **kwargs)
class gr_pfb_interpolator_ccf_sptr(object):
    """Proxy of C++ boost::shared_ptr<(gr_pfb_interpolator_ccf)> class"""
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(self) -> gr_pfb_interpolator_ccf_sptr
        __init__(self,  p) -> gr_pfb_interpolator_ccf_sptr
        """
        this = _gnuradio_core_filter.new_gr_pfb_interpolator_ccf_sptr(*args)
        try: self.this.append(this)
        except: self.this = this
    def __deref__(self):
        """__deref__(self)"""
        return _gnuradio_core_filter.gr_pfb_interpolator_ccf_sptr___deref__(self)

    __swig_destroy__ = _gnuradio_core_filter.delete_gr_pfb_interpolator_ccf_sptr
    __del__ = lambda self : None;
    def set_taps(self, *args, **kwargs):
        """
        set_taps(self, __dummy_4__ taps)

        Resets the filterbank's filter taps with the new prototype filter
        """
        return _gnuradio_core_filter.gr_pfb_interpolator_ccf_sptr_set_taps(self, *args, **kwargs)

    def print_taps(self):
        """
        print_taps(self)

        Print all of the filterbank taps to screen.
        """
        return _gnuradio_core_filter.gr_pfb_interpolator_ccf_sptr_print_taps(self)

    def history(self):
        """history(self) -> unsigned int"""
        return _gnuradio_core_filter.gr_pfb_interpolator_ccf_sptr_history(self)

    def output_multiple(self):
        """output_multiple(self) -> int"""
        return _gnuradio_core_filter.gr_pfb_interpolator_ccf_sptr_output_multiple(self)

    def relative_rate(self):
        """relative_rate(self) -> double"""
        return _gnuradio_core_filter.gr_pfb_interpolator_ccf_sptr_relative_rate(self)

    def start(self):
        """start(self) -> bool"""
        return _gnuradio_core_filter.gr_pfb_interpolator_ccf_sptr_start(self)

    def stop(self):
        """stop(self) -> bool"""
        return _gnuradio_core_filter.gr_pfb_interpolator_ccf_sptr_stop(self)

    def nitems_read(self, *args, **kwargs):
        """nitems_read(self, unsigned int which_input) -> uint64_t"""
        return _gnuradio_core_filter.gr_pfb_interpolator_ccf_sptr_nitems_read(self, *args, **kwargs)

    def nitems_written(self, *args, **kwargs):
        """nitems_written(self, unsigned int which_output) -> uint64_t"""
        return _gnuradio_core_filter.gr_pfb_interpolator_ccf_sptr_nitems_written(self, *args, **kwargs)

    def detail(self):
        """detail(self) -> gr_block_detail_sptr"""
        return _gnuradio_core_filter.gr_pfb_interpolator_ccf_sptr_detail(self)

    def set_detail(self, *args, **kwargs):
        """set_detail(self, gr_block_detail_sptr detail)"""
        return _gnuradio_core_filter.gr_pfb_interpolator_ccf_sptr_set_detail(self, *args, **kwargs)

    def name(self):
        """name(self) -> string"""
        return _gnuradio_core_filter.gr_pfb_interpolator_ccf_sptr_name(self)

    def input_signature(self):
        """input_signature(self) -> gr_io_signature_sptr"""
        return _gnuradio_core_filter.gr_pfb_interpolator_ccf_sptr_input_signature(self)

    def output_signature(self):
        """output_signature(self) -> gr_io_signature_sptr"""
        return _gnuradio_core_filter.gr_pfb_interpolator_ccf_sptr_output_signature(self)

    def unique_id(self):
        """unique_id(self) -> long"""
        return _gnuradio_core_filter.gr_pfb_interpolator_ccf_sptr_unique_id(self)

    def to_basic_block(self):
        """to_basic_block(self) -> gr_basic_block_sptr"""
        return _gnuradio_core_filter.gr_pfb_interpolator_ccf_sptr_to_basic_block(self)

    def check_topology(self, *args, **kwargs):
        """check_topology(self, int ninputs, int noutputs) -> bool"""
        return _gnuradio_core_filter.gr_pfb_interpolator_ccf_sptr_check_topology(self, *args, **kwargs)

gr_pfb_interpolator_ccf_sptr_swigregister = _gnuradio_core_filter.gr_pfb_interpolator_ccf_sptr_swigregister
gr_pfb_interpolator_ccf_sptr_swigregister(gr_pfb_interpolator_ccf_sptr)

gr_pfb_interpolator_ccf_sptr.__repr__ = lambda self: "<gr_block %s (%d)>" % (self.name(), self.unique_id ())


def pfb_interpolator_ccf(*args, **kwargs):
  """
    pfb_interpolator_ccf(unsigned int interp, __dummy_4__ taps) -> gr_pfb_interpolator_ccf_sptr

    Polyphase filterbank interpolator with gr_complex input, gr_complex output and float taps.

    This block takes in a signal stream and performs interger up- sampling (interpolation) with a polyphase filterbank. The first input is the integer specifying how much to interpolate by. The second input is a vector (Python list) of floating-point taps of the prototype filter.

    The filter's taps should be based on the interpolation rate specified. That is, the bandwidth specified is relative to the bandwidth after interpolation.

    For example, using the GNU Radio's firdes utility to building filters, we build a low-pass filter with a sampling rate of , a 3-dB bandwidth of  and a transition bandwidth of . We can also specify the out-of-band attenuation to use, ATT, and the filter window function (a Blackman-harris window in this case). The first input is the gain, which is also specified as the interpolation rate so that the output levels are the same as the input (this creates an overall increase in power).



    The PFB interpolator code takes the taps generated above and builds a set of filters. The set contains  number of filters and each filter contains ceil(taps.size()/interp) number of taps. Each tap from the filter prototype is sequentially inserted into the next filter. When all of the input taps are used, the remaining filters in the filterbank are filled out with 0's to make sure each filter has the same number of taps.

    The theory behind this block can be found in Chapter 7.1 of the following book.

    Build the polyphase filterbank interpolator.
    """
  return _gnuradio_core_filter.pfb_interpolator_ccf(*args, **kwargs)
class gr_pfb_arb_resampler_ccf_sptr(object):
    """Proxy of C++ boost::shared_ptr<(gr_pfb_arb_resampler_ccf)> class"""
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(self) -> gr_pfb_arb_resampler_ccf_sptr
        __init__(self,  p) -> gr_pfb_arb_resampler_ccf_sptr
        """
        this = _gnuradio_core_filter.new_gr_pfb_arb_resampler_ccf_sptr(*args)
        try: self.this.append(this)
        except: self.this = this
    def __deref__(self):
        """__deref__(self)"""
        return _gnuradio_core_filter.gr_pfb_arb_resampler_ccf_sptr___deref__(self)

    __swig_destroy__ = _gnuradio_core_filter.delete_gr_pfb_arb_resampler_ccf_sptr
    __del__ = lambda self : None;
    def print_taps(self):
        """
        print_taps(self)

        Print all of the filterbank taps to screen.
        """
        return _gnuradio_core_filter.gr_pfb_arb_resampler_ccf_sptr_print_taps(self)

    def set_rate(self, *args, **kwargs):
        """set_rate(self, float rate)"""
        return _gnuradio_core_filter.gr_pfb_arb_resampler_ccf_sptr_set_rate(self, *args, **kwargs)

    def history(self):
        """history(self) -> unsigned int"""
        return _gnuradio_core_filter.gr_pfb_arb_resampler_ccf_sptr_history(self)

    def output_multiple(self):
        """output_multiple(self) -> int"""
        return _gnuradio_core_filter.gr_pfb_arb_resampler_ccf_sptr_output_multiple(self)

    def relative_rate(self):
        """relative_rate(self) -> double"""
        return _gnuradio_core_filter.gr_pfb_arb_resampler_ccf_sptr_relative_rate(self)

    def start(self):
        """start(self) -> bool"""
        return _gnuradio_core_filter.gr_pfb_arb_resampler_ccf_sptr_start(self)

    def stop(self):
        """stop(self) -> bool"""
        return _gnuradio_core_filter.gr_pfb_arb_resampler_ccf_sptr_stop(self)

    def nitems_read(self, *args, **kwargs):
        """nitems_read(self, unsigned int which_input) -> uint64_t"""
        return _gnuradio_core_filter.gr_pfb_arb_resampler_ccf_sptr_nitems_read(self, *args, **kwargs)

    def nitems_written(self, *args, **kwargs):
        """nitems_written(self, unsigned int which_output) -> uint64_t"""
        return _gnuradio_core_filter.gr_pfb_arb_resampler_ccf_sptr_nitems_written(self, *args, **kwargs)

    def detail(self):
        """detail(self) -> gr_block_detail_sptr"""
        return _gnuradio_core_filter.gr_pfb_arb_resampler_ccf_sptr_detail(self)

    def set_detail(self, *args, **kwargs):
        """set_detail(self, gr_block_detail_sptr detail)"""
        return _gnuradio_core_filter.gr_pfb_arb_resampler_ccf_sptr_set_detail(self, *args, **kwargs)

    def name(self):
        """name(self) -> string"""
        return _gnuradio_core_filter.gr_pfb_arb_resampler_ccf_sptr_name(self)

    def input_signature(self):
        """input_signature(self) -> gr_io_signature_sptr"""
        return _gnuradio_core_filter.gr_pfb_arb_resampler_ccf_sptr_input_signature(self)

    def output_signature(self):
        """output_signature(self) -> gr_io_signature_sptr"""
        return _gnuradio_core_filter.gr_pfb_arb_resampler_ccf_sptr_output_signature(self)

    def unique_id(self):
        """unique_id(self) -> long"""
        return _gnuradio_core_filter.gr_pfb_arb_resampler_ccf_sptr_unique_id(self)

    def to_basic_block(self):
        """to_basic_block(self) -> gr_basic_block_sptr"""
        return _gnuradio_core_filter.gr_pfb_arb_resampler_ccf_sptr_to_basic_block(self)

    def check_topology(self, *args, **kwargs):
        """check_topology(self, int ninputs, int noutputs) -> bool"""
        return _gnuradio_core_filter.gr_pfb_arb_resampler_ccf_sptr_check_topology(self, *args, **kwargs)

gr_pfb_arb_resampler_ccf_sptr_swigregister = _gnuradio_core_filter.gr_pfb_arb_resampler_ccf_sptr_swigregister
gr_pfb_arb_resampler_ccf_sptr_swigregister(gr_pfb_arb_resampler_ccf_sptr)

gr_pfb_arb_resampler_ccf_sptr.__repr__ = lambda self: "<gr_block %s (%d)>" % (self.name(), self.unique_id ())


def pfb_arb_resampler_ccf(*args, **kwargs):
  """
    pfb_arb_resampler_ccf(float rate, __dummy_4__ taps, unsigned int filter_size = 32) -> gr_pfb_arb_resampler_ccf_sptr

    Polyphase filterbank arbitrary resampler with gr_complex input, gr_complex output and float taps.

    This block takes in a signal stream and performs arbitrary resampling. The resampling rate can be any real number . The resampling is done by constructing  filters where  is the interpolation rate. We then calculate  where .

    Using  and , we can perform rational resampling where  is a rational number close to the input rate  where we have  filters and we cycle through them as a polyphase filterbank with a stride of  so that .

    To get the arbitrary rate, we want to interpolate between two points. For each value out, we take an output from the current filter, , and the next filter  and then linearly interpolate between the two based on the real resampling rate we want.

    The linear interpolation only provides us with an approximation to the real sampling rate specified. The error is a quantization error between the two filters we used as our interpolation points. To this end, the number of filters, , used determines the quantization error; the larger , the smaller the noise. You can design for a specified noise floor by setting the filter size (parameters ). The size defaults to 32 filters, which is about as good as most implementations need.

    The trick with designing this filter is in how to specify the taps of the prototype filter. Like the PFB interpolator, the taps are specified using the interpolated filter rate. In this case, that rate is the input sample rate multiplied by the number of filters in the filterbank, which is also the interpolation rate. All other values should be relative to this rate.

    For example, for a 32-filter arbitrary resampler and using the GNU Radio's firdes utility to build the filter, we build a low-pass filter with a sampling rate of , a 3-dB bandwidth of  and a transition bandwidth of . We can also specify the out-of-band attenuation to use, , and the filter window function (a Blackman-harris window in this case). The first input is the gain of the filter, which we specify here as the interpolation rate ().



    The theory behind this block can be found in Chapter 7.5 of the following book.

    Build the polyphase filterbank arbitray resampler.
    """
  return _gnuradio_core_filter.pfb_arb_resampler_ccf(*args, **kwargs)
class gr_pfb_arb_resampler_fff_sptr(object):
    """Proxy of C++ boost::shared_ptr<(gr_pfb_arb_resampler_fff)> class"""
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(self) -> gr_pfb_arb_resampler_fff_sptr
        __init__(self,  p) -> gr_pfb_arb_resampler_fff_sptr
        """
        this = _gnuradio_core_filter.new_gr_pfb_arb_resampler_fff_sptr(*args)
        try: self.this.append(this)
        except: self.this = this
    def __deref__(self):
        """__deref__(self)"""
        return _gnuradio_core_filter.gr_pfb_arb_resampler_fff_sptr___deref__(self)

    __swig_destroy__ = _gnuradio_core_filter.delete_gr_pfb_arb_resampler_fff_sptr
    __del__ = lambda self : None;
    def print_taps(self):
        """
        print_taps(self)

        Print all of the filterbank taps to screen.
        """
        return _gnuradio_core_filter.gr_pfb_arb_resampler_fff_sptr_print_taps(self)

    def set_rate(self, *args, **kwargs):
        """set_rate(self, float rate)"""
        return _gnuradio_core_filter.gr_pfb_arb_resampler_fff_sptr_set_rate(self, *args, **kwargs)

    def history(self):
        """history(self) -> unsigned int"""
        return _gnuradio_core_filter.gr_pfb_arb_resampler_fff_sptr_history(self)

    def output_multiple(self):
        """output_multiple(self) -> int"""
        return _gnuradio_core_filter.gr_pfb_arb_resampler_fff_sptr_output_multiple(self)

    def relative_rate(self):
        """relative_rate(self) -> double"""
        return _gnuradio_core_filter.gr_pfb_arb_resampler_fff_sptr_relative_rate(self)

    def start(self):
        """start(self) -> bool"""
        return _gnuradio_core_filter.gr_pfb_arb_resampler_fff_sptr_start(self)

    def stop(self):
        """stop(self) -> bool"""
        return _gnuradio_core_filter.gr_pfb_arb_resampler_fff_sptr_stop(self)

    def nitems_read(self, *args, **kwargs):
        """nitems_read(self, unsigned int which_input) -> uint64_t"""
        return _gnuradio_core_filter.gr_pfb_arb_resampler_fff_sptr_nitems_read(self, *args, **kwargs)

    def nitems_written(self, *args, **kwargs):
        """nitems_written(self, unsigned int which_output) -> uint64_t"""
        return _gnuradio_core_filter.gr_pfb_arb_resampler_fff_sptr_nitems_written(self, *args, **kwargs)

    def detail(self):
        """detail(self) -> gr_block_detail_sptr"""
        return _gnuradio_core_filter.gr_pfb_arb_resampler_fff_sptr_detail(self)

    def set_detail(self, *args, **kwargs):
        """set_detail(self, gr_block_detail_sptr detail)"""
        return _gnuradio_core_filter.gr_pfb_arb_resampler_fff_sptr_set_detail(self, *args, **kwargs)

    def name(self):
        """name(self) -> string"""
        return _gnuradio_core_filter.gr_pfb_arb_resampler_fff_sptr_name(self)

    def input_signature(self):
        """input_signature(self) -> gr_io_signature_sptr"""
        return _gnuradio_core_filter.gr_pfb_arb_resampler_fff_sptr_input_signature(self)

    def output_signature(self):
        """output_signature(self) -> gr_io_signature_sptr"""
        return _gnuradio_core_filter.gr_pfb_arb_resampler_fff_sptr_output_signature(self)

    def unique_id(self):
        """unique_id(self) -> long"""
        return _gnuradio_core_filter.gr_pfb_arb_resampler_fff_sptr_unique_id(self)

    def to_basic_block(self):
        """to_basic_block(self) -> gr_basic_block_sptr"""
        return _gnuradio_core_filter.gr_pfb_arb_resampler_fff_sptr_to_basic_block(self)

    def check_topology(self, *args, **kwargs):
        """check_topology(self, int ninputs, int noutputs) -> bool"""
        return _gnuradio_core_filter.gr_pfb_arb_resampler_fff_sptr_check_topology(self, *args, **kwargs)

gr_pfb_arb_resampler_fff_sptr_swigregister = _gnuradio_core_filter.gr_pfb_arb_resampler_fff_sptr_swigregister
gr_pfb_arb_resampler_fff_sptr_swigregister(gr_pfb_arb_resampler_fff_sptr)

gr_pfb_arb_resampler_fff_sptr.__repr__ = lambda self: "<gr_block %s (%d)>" % (self.name(), self.unique_id ())


def pfb_arb_resampler_fff(*args, **kwargs):
  """
    pfb_arb_resampler_fff(float rate, __dummy_4__ taps, unsigned int filter_size = 32) -> gr_pfb_arb_resampler_fff_sptr

    Polyphase filterbank arbitrary resampler with float input, float output and float taps.

    This block takes in a signal stream and performs arbitrary resampling. The resampling rate can be any real number . The resampling is done by constructing  filters where  is the interpolation rate. We then calculate  where .

    Using  and , we can perform rational resampling where  is a rational number close to the input rate  where we have  filters and we cycle through them as a polyphase filterbank with a stride of  so that .

    To get the arbitrary rate, we want to interpolate between two points. For each value out, we take an output from the current filter, , and the next filter  and then linearly interpolate between the two based on the real resampling rate we want.

    The linear interpolation only provides us with an approximation to the real sampling rate specified. The error is a quantization error between the two filters we used as our interpolation points. To this end, the number of filters, , used determines the quantization error; the larger , the smaller the noise. You can design for a specified noise floor by setting the filter size (parameters ). The size defaults to 32 filters, which is about as good as most implementations need.

    The trick with designing this filter is in how to specify the taps of the prototype filter. Like the PFB interpolator, the taps are specified using the interpolated filter rate. In this case, that rate is the input sample rate multiplied by the number of filters in the filterbank, which is also the interpolation rate. All other values should be relative to this rate.

    For example, for a 32-filter arbitrary resampler and using the GNU Radio's firdes utility to build the filter, we build a low-pass filter with a sampling rate of , a 3-dB bandwidth of  and a transition bandwidth of . We can also specify the out-of-band attenuation to use, , and the filter window function (a Blackman-harris window in this case). The first input is the gain of the filter, which we specify here as the interpolation rate ().



    The theory behind this block can be found in Chapter 7.5 of the following book.

    Build the polyphase filterbank arbitray resampler.
    """
  return _gnuradio_core_filter.pfb_arb_resampler_fff(*args, **kwargs)
class gr_pfb_clock_sync_ccf_sptr(object):
    """Proxy of C++ boost::shared_ptr<(gr_pfb_clock_sync_ccf)> class"""
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(self) -> gr_pfb_clock_sync_ccf_sptr
        __init__(self,  p) -> gr_pfb_clock_sync_ccf_sptr
        """
        this = _gnuradio_core_filter.new_gr_pfb_clock_sync_ccf_sptr(*args)
        try: self.this.append(this)
        except: self.this = this
    def __deref__(self):
        """__deref__(self)"""
        return _gnuradio_core_filter.gr_pfb_clock_sync_ccf_sptr___deref__(self)

    __swig_destroy__ = _gnuradio_core_filter.delete_gr_pfb_clock_sync_ccf_sptr
    __del__ = lambda self : None;
    def set_taps(self, *args, **kwargs):
        """
        set_taps(self, __dummy_4__ taps, __dummy_11__ ourtaps, std::vector<(p.gr_fir_ccf,std::allocator<(p.gr_fir_ccf)>)> ourfilter)

        Resets the filterbank's filter taps with the new prototype filter
        """
        return _gnuradio_core_filter.gr_pfb_clock_sync_ccf_sptr_set_taps(self, *args, **kwargs)

    def get_taps(self):
        """
        get_taps(self) -> __dummy_11__

        Returns all of the taps of the matched filter
        """
        return _gnuradio_core_filter.gr_pfb_clock_sync_ccf_sptr_get_taps(self)

    def get_diff_taps(self):
        """
        get_diff_taps(self) -> __dummy_11__

        Returns all of the taps of the derivative filter
        """
        return _gnuradio_core_filter.gr_pfb_clock_sync_ccf_sptr_get_diff_taps(self)

    def get_channel_taps(self, *args, **kwargs):
        """
        get_channel_taps(self, int channel) -> __dummy_4__

        Returns the taps of the matched filter for a particular channel
        """
        return _gnuradio_core_filter.gr_pfb_clock_sync_ccf_sptr_get_channel_taps(self, *args, **kwargs)

    def get_diff_channel_taps(self, *args, **kwargs):
        """
        get_diff_channel_taps(self, int channel) -> __dummy_4__

        Returns the taps in the derivative filter for a particular channel
        """
        return _gnuradio_core_filter.gr_pfb_clock_sync_ccf_sptr_get_diff_channel_taps(self, *args, **kwargs)

    def get_taps_as_string(self):
        """
        get_taps_as_string(self) -> string

        Return the taps as a formatted string for printing
        """
        return _gnuradio_core_filter.gr_pfb_clock_sync_ccf_sptr_get_taps_as_string(self)

    def get_diff_taps_as_string(self):
        """
        get_diff_taps_as_string(self) -> string

        Return the derivative filter taps as a formatted string for printing
        """
        return _gnuradio_core_filter.gr_pfb_clock_sync_ccf_sptr_get_diff_taps_as_string(self)

    def set_loop_bandwidth(self, *args, **kwargs):
        """
        set_loop_bandwidth(self, float bw)

        Set the loop bandwidth.

        Set the loop filter's bandwidth to . This should be between 2*pi/200 and 2*pi/100 (in rads/samp). It must also be a positive number.

        When a new damping factor is set, the gains, alpha and beta, of the loop are recalculated by a call to update_gains().
        """
        return _gnuradio_core_filter.gr_pfb_clock_sync_ccf_sptr_set_loop_bandwidth(self, *args, **kwargs)

    def set_damping_factor(self, *args, **kwargs):
        """
        set_damping_factor(self, float df)

        Set the loop damping factor.

        Set the loop filter's damping factor to . The damping factor should be sqrt(2)/2.0 for critically damped systems. Set it to anything else only if you know what you are doing. It must be a number between 0 and 1.

        When a new damping factor is set, the gains, alpha and beta, of the loop are recalculated by a call to update_gains().
        """
        return _gnuradio_core_filter.gr_pfb_clock_sync_ccf_sptr_set_damping_factor(self, *args, **kwargs)

    def set_alpha(self, *args, **kwargs):
        """
        set_alpha(self, float alpha)

        Set the loop gain alpha.

        Set's the loop filter's alpha gain parameter.

        This value should really only be set by adjusting the loop bandwidth and damping factor.
        """
        return _gnuradio_core_filter.gr_pfb_clock_sync_ccf_sptr_set_alpha(self, *args, **kwargs)

    def set_beta(self, *args, **kwargs):
        """
        set_beta(self, float beta)

        Set the loop gain beta.

        Set's the loop filter's beta gain parameter.

        This value should really only be set by adjusting the loop bandwidth and damping factor.
        """
        return _gnuradio_core_filter.gr_pfb_clock_sync_ccf_sptr_set_beta(self, *args, **kwargs)

    def set_max_rate_deviation(self, *args, **kwargs):
        """
        set_max_rate_deviation(self, float m)

        Set the maximum deviation from 0 d_rate can have
        """
        return _gnuradio_core_filter.gr_pfb_clock_sync_ccf_sptr_set_max_rate_deviation(self, *args, **kwargs)

    def get_loop_bandwidth(self):
        """
        get_loop_bandwidth(self) -> float

        Returns the loop bandwidth.
        """
        return _gnuradio_core_filter.gr_pfb_clock_sync_ccf_sptr_get_loop_bandwidth(self)

    def get_damping_factor(self):
        """
        get_damping_factor(self) -> float

        Returns the loop damping factor.
        """
        return _gnuradio_core_filter.gr_pfb_clock_sync_ccf_sptr_get_damping_factor(self)

    def get_alpha(self):
        """
        get_alpha(self) -> float

        Returns the loop gain alpha.
        """
        return _gnuradio_core_filter.gr_pfb_clock_sync_ccf_sptr_get_alpha(self)

    def get_beta(self):
        """
        get_beta(self) -> float

        Returns the loop gain beta.
        """
        return _gnuradio_core_filter.gr_pfb_clock_sync_ccf_sptr_get_beta(self)

    def get_clock_rate(self):
        """
        get_clock_rate(self) -> float

        Returns the current clock rate.
        """
        return _gnuradio_core_filter.gr_pfb_clock_sync_ccf_sptr_get_clock_rate(self)

    def history(self):
        """history(self) -> unsigned int"""
        return _gnuradio_core_filter.gr_pfb_clock_sync_ccf_sptr_history(self)

    def output_multiple(self):
        """output_multiple(self) -> int"""
        return _gnuradio_core_filter.gr_pfb_clock_sync_ccf_sptr_output_multiple(self)

    def relative_rate(self):
        """relative_rate(self) -> double"""
        return _gnuradio_core_filter.gr_pfb_clock_sync_ccf_sptr_relative_rate(self)

    def start(self):
        """start(self) -> bool"""
        return _gnuradio_core_filter.gr_pfb_clock_sync_ccf_sptr_start(self)

    def stop(self):
        """stop(self) -> bool"""
        return _gnuradio_core_filter.gr_pfb_clock_sync_ccf_sptr_stop(self)

    def nitems_read(self, *args, **kwargs):
        """nitems_read(self, unsigned int which_input) -> uint64_t"""
        return _gnuradio_core_filter.gr_pfb_clock_sync_ccf_sptr_nitems_read(self, *args, **kwargs)

    def nitems_written(self, *args, **kwargs):
        """nitems_written(self, unsigned int which_output) -> uint64_t"""
        return _gnuradio_core_filter.gr_pfb_clock_sync_ccf_sptr_nitems_written(self, *args, **kwargs)

    def detail(self):
        """detail(self) -> gr_block_detail_sptr"""
        return _gnuradio_core_filter.gr_pfb_clock_sync_ccf_sptr_detail(self)

    def set_detail(self, *args, **kwargs):
        """set_detail(self, gr_block_detail_sptr detail)"""
        return _gnuradio_core_filter.gr_pfb_clock_sync_ccf_sptr_set_detail(self, *args, **kwargs)

    def name(self):
        """name(self) -> string"""
        return _gnuradio_core_filter.gr_pfb_clock_sync_ccf_sptr_name(self)

    def input_signature(self):
        """input_signature(self) -> gr_io_signature_sptr"""
        return _gnuradio_core_filter.gr_pfb_clock_sync_ccf_sptr_input_signature(self)

    def output_signature(self):
        """output_signature(self) -> gr_io_signature_sptr"""
        return _gnuradio_core_filter.gr_pfb_clock_sync_ccf_sptr_output_signature(self)

    def unique_id(self):
        """unique_id(self) -> long"""
        return _gnuradio_core_filter.gr_pfb_clock_sync_ccf_sptr_unique_id(self)

    def to_basic_block(self):
        """to_basic_block(self) -> gr_basic_block_sptr"""
        return _gnuradio_core_filter.gr_pfb_clock_sync_ccf_sptr_to_basic_block(self)

    def check_topology(self, *args, **kwargs):
        """check_topology(self, int ninputs, int noutputs) -> bool"""
        return _gnuradio_core_filter.gr_pfb_clock_sync_ccf_sptr_check_topology(self, *args, **kwargs)

gr_pfb_clock_sync_ccf_sptr_swigregister = _gnuradio_core_filter.gr_pfb_clock_sync_ccf_sptr_swigregister
gr_pfb_clock_sync_ccf_sptr_swigregister(gr_pfb_clock_sync_ccf_sptr)

gr_pfb_clock_sync_ccf_sptr.__repr__ = lambda self: "<gr_block %s (%d)>" % (self.name(), self.unique_id ())


def pfb_clock_sync_ccf(*args, **kwargs):
  """
    pfb_clock_sync_ccf(double sps, float loop_bw, __dummy_4__ taps, unsigned int filter_size = 32, 
        float init_phase = 0, 
        float max_rate_deviation = 1.5, int osps = 1) -> gr_pfb_clock_sync_ccf_sptr

    Timing synchronizer using polyphase filterbanks.

    This block performs timing synchronization for PAM signals by minimizing the derivative of the filtered signal, which in turn maximizes the SNR and minimizes ISI.

    This approach works by setting up two filterbanks; one filterbank contains the signal's pulse shaping matched filter (such as a root raised cosine filter), where each branch of the filterbank contains a different phase of the filter. The second filterbank contains the derivatives of the filters in the first filterbank. Thinking of this in the time domain, the first filterbank contains filters that have a sinc shape to them. We want to align the output signal to be sampled at exactly the peak of the sinc shape. The derivative of the sinc contains a zero at the maximum point of the sinc (sinc(0) = 1, sinc(0)' = 0). Furthermore, the region around the zero point is relatively linear. We make use of this fact to generate the error signal.

    If the signal out of the derivative filters is d_i[n] for the ith filter, and the output of the matched filter is x_i[n], we calculate the error as: e[n] = (Re{x_i[n]} * Re{d_i[n]} + Im{x_i[n]} * Im{d_i[n]}) / 2.0 This equation averages the error in the real and imaginary parts. There are two reasons we multiply by the signal itself. First, if the symbol could be positive or negative going, but we want the error term to always tell us to go in the same direction depending on which side of the zero point we are on. The sign of x_i[n] adjusts the error term to do this. Second, the magnitude of x_i[n] scales the error term depending on the symbol's amplitude, so larger signals give us a stronger error term because we have more confidence in that symbol's value. Using the magnitude of x_i[n] instead of just the sign is especially good for signals with low SNR.

    The error signal, e[n], gives us a value proportional to how far away from the zero point we are in the derivative signal. We want to drive this value to zero, so we set up a second order loop. We have two variables for this loop; d_k is the filter number in the filterbank we are on and d_rate is the rate which we travel through the filters in the steady state. That is, due to the natural clock differences between the transmitter and receiver, d_rate represents that difference and would traverse the filter phase paths to keep the receiver locked. Thinking of this as a second-order PLL, the d_rate is the frequency and d_k is the phase. So we update d_rate and d_k using the standard loop equations based on two error signals, d_alpha and d_beta. We have these two values set based on each other for a critically damped system, so in the block constructor, we just ask for "gain," which is d_alpha while d_beta is equal to (gain^2)/4.

    The block's parameters are:

    Build the polyphase filterbank timing synchronizer.
    """
  return _gnuradio_core_filter.pfb_clock_sync_ccf(*args, **kwargs)
class gr_pfb_clock_sync_fff_sptr(object):
    """Proxy of C++ boost::shared_ptr<(gr_pfb_clock_sync_fff)> class"""
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(self) -> gr_pfb_clock_sync_fff_sptr
        __init__(self,  p) -> gr_pfb_clock_sync_fff_sptr
        """
        this = _gnuradio_core_filter.new_gr_pfb_clock_sync_fff_sptr(*args)
        try: self.this.append(this)
        except: self.this = this
    def __deref__(self):
        """__deref__(self)"""
        return _gnuradio_core_filter.gr_pfb_clock_sync_fff_sptr___deref__(self)

    __swig_destroy__ = _gnuradio_core_filter.delete_gr_pfb_clock_sync_fff_sptr
    __del__ = lambda self : None;
    def set_taps(self, *args, **kwargs):
        """
        set_taps(self, __dummy_4__ taps, __dummy_11__ ourtaps, std::vector<(p.gr_fir_fff,std::allocator<(p.gr_fir_fff)>)> ourfilter)

        Resets the filterbank's filter taps with the new prototype filter
        """
        return _gnuradio_core_filter.gr_pfb_clock_sync_fff_sptr_set_taps(self, *args, **kwargs)

    def channel_taps(self, *args, **kwargs):
        """
        channel_taps(self, int channel) -> __dummy_4__

        Returns the taps of the matched filter
        """
        return _gnuradio_core_filter.gr_pfb_clock_sync_fff_sptr_channel_taps(self, *args, **kwargs)

    def diff_channel_taps(self, *args, **kwargs):
        """
        diff_channel_taps(self, int channel) -> __dummy_4__

        Returns the taps in the derivative filter
        """
        return _gnuradio_core_filter.gr_pfb_clock_sync_fff_sptr_diff_channel_taps(self, *args, **kwargs)

    def print_taps(self):
        """
        print_taps(self)

        Print all of the filterbank taps to screen.
        """
        return _gnuradio_core_filter.gr_pfb_clock_sync_fff_sptr_print_taps(self)

    def print_diff_taps(self):
        """
        print_diff_taps(self)

        Print all of the filterbank taps of the derivative filter to screen.
        """
        return _gnuradio_core_filter.gr_pfb_clock_sync_fff_sptr_print_diff_taps(self)

    def set_alpha(self, *args, **kwargs):
        """
        set_alpha(self, float alpha)

        Set the gain value alpha for the control loop
        """
        return _gnuradio_core_filter.gr_pfb_clock_sync_fff_sptr_set_alpha(self, *args, **kwargs)

    def set_beta(self, *args, **kwargs):
        """
        set_beta(self, float beta)

        Set the gain value beta for the control loop
        """
        return _gnuradio_core_filter.gr_pfb_clock_sync_fff_sptr_set_beta(self, *args, **kwargs)

    def set_max_rate_deviation(self, *args, **kwargs):
        """
        set_max_rate_deviation(self, float m)

        Set the maximum deviation from 0 d_rate can have
        """
        return _gnuradio_core_filter.gr_pfb_clock_sync_fff_sptr_set_max_rate_deviation(self, *args, **kwargs)

    def history(self):
        """history(self) -> unsigned int"""
        return _gnuradio_core_filter.gr_pfb_clock_sync_fff_sptr_history(self)

    def output_multiple(self):
        """output_multiple(self) -> int"""
        return _gnuradio_core_filter.gr_pfb_clock_sync_fff_sptr_output_multiple(self)

    def relative_rate(self):
        """relative_rate(self) -> double"""
        return _gnuradio_core_filter.gr_pfb_clock_sync_fff_sptr_relative_rate(self)

    def start(self):
        """start(self) -> bool"""
        return _gnuradio_core_filter.gr_pfb_clock_sync_fff_sptr_start(self)

    def stop(self):
        """stop(self) -> bool"""
        return _gnuradio_core_filter.gr_pfb_clock_sync_fff_sptr_stop(self)

    def nitems_read(self, *args, **kwargs):
        """nitems_read(self, unsigned int which_input) -> uint64_t"""
        return _gnuradio_core_filter.gr_pfb_clock_sync_fff_sptr_nitems_read(self, *args, **kwargs)

    def nitems_written(self, *args, **kwargs):
        """nitems_written(self, unsigned int which_output) -> uint64_t"""
        return _gnuradio_core_filter.gr_pfb_clock_sync_fff_sptr_nitems_written(self, *args, **kwargs)

    def detail(self):
        """detail(self) -> gr_block_detail_sptr"""
        return _gnuradio_core_filter.gr_pfb_clock_sync_fff_sptr_detail(self)

    def set_detail(self, *args, **kwargs):
        """set_detail(self, gr_block_detail_sptr detail)"""
        return _gnuradio_core_filter.gr_pfb_clock_sync_fff_sptr_set_detail(self, *args, **kwargs)

    def name(self):
        """name(self) -> string"""
        return _gnuradio_core_filter.gr_pfb_clock_sync_fff_sptr_name(self)

    def input_signature(self):
        """input_signature(self) -> gr_io_signature_sptr"""
        return _gnuradio_core_filter.gr_pfb_clock_sync_fff_sptr_input_signature(self)

    def output_signature(self):
        """output_signature(self) -> gr_io_signature_sptr"""
        return _gnuradio_core_filter.gr_pfb_clock_sync_fff_sptr_output_signature(self)

    def unique_id(self):
        """unique_id(self) -> long"""
        return _gnuradio_core_filter.gr_pfb_clock_sync_fff_sptr_unique_id(self)

    def to_basic_block(self):
        """to_basic_block(self) -> gr_basic_block_sptr"""
        return _gnuradio_core_filter.gr_pfb_clock_sync_fff_sptr_to_basic_block(self)

    def check_topology(self, *args, **kwargs):
        """check_topology(self, int ninputs, int noutputs) -> bool"""
        return _gnuradio_core_filter.gr_pfb_clock_sync_fff_sptr_check_topology(self, *args, **kwargs)

gr_pfb_clock_sync_fff_sptr_swigregister = _gnuradio_core_filter.gr_pfb_clock_sync_fff_sptr_swigregister
gr_pfb_clock_sync_fff_sptr_swigregister(gr_pfb_clock_sync_fff_sptr)

gr_pfb_clock_sync_fff_sptr.__repr__ = lambda self: "<gr_block %s (%d)>" % (self.name(), self.unique_id ())


def pfb_clock_sync_fff(*args, **kwargs):
  """
    pfb_clock_sync_fff(double sps, float gain, __dummy_4__ taps, unsigned int filter_size = 32, 
        float init_phase = 0, float max_rate_deviation = 1.5) -> gr_pfb_clock_sync_fff_sptr

    Timing synchronizer using polyphase filterbanks.

    This block performs timing synchronization for PAM signals by minimizing the derivative of the filtered signal, which in turn maximizes the SNR and minimizes ISI.

    This approach works by setting up two filterbanks; one filterbank contains the signal's pulse shaping matched filter (such as a root raised cosine filter), where each branch of the filterbank contains a different phase of the filter. The second filterbank contains the derivatives of the filters in the first filterbank. Thinking of this in the time domain, the first filterbank contains filters that have a sinc shape to them. We want to align the output signal to be sampled at exactly the peak of the sinc shape. The derivative of the sinc contains a zero at the maximum point of the sinc (sinc(0) = 1, sinc(0)' = 0). Furthermore, the region around the zero point is relatively linear. We make use of this fact to generate the error signal.

    If the signal out of the derivative filters is d_i[n] for the ith filter, and the output of the matched filter is x_i[n], we calculate the error as: e[n] = (Re{x_i[n]} * Re{d_i[n]} + Im{x_i[n]} * Im{d_i[n]}) / 2.0 This equation averages the error in the real and imaginary parts. There are two reasons we multiply by the signal itself. First, if the symbol could be positive or negative going, but we want the error term to always tell us to go in the same direction depending on which side of the zero point we are on. The sign of x_i[n] adjusts the error term to do this. Second, the magnitude of x_i[n] scales the error term depending on the symbol's amplitude, so larger signals give us a stronger error term because we have more confidence in that symbol's value. Using the magnitude of x_i[n] instead of just the sign is especially good for signals with low SNR.

    The error signal, e[n], gives us a value proportional to how far away from the zero point we are in the derivative signal. We want to drive this value to zero, so we set up a second order loop. We have two variables for this loop; d_k is the filter number in the filterbank we are on and d_rate is the rate which we travel through the filters in the steady state. That is, due to the natural clock differences between the transmitter and receiver, d_rate represents that difference and would traverse the filter phase paths to keep the receiver locked. Thinking of this as a second-order PLL, the d_rate is the frequency and d_k is the phase. So we update d_rate and d_k using the standard loop equations based on two error signals, d_alpha and d_beta. We have these two values set based on each other for a critically damped system, so in the block constructor, we just ask for "gain," which is d_alpha while d_beta is equal to (gain^2)/4.

    The block's parameters are:

    Build the polyphase filterbank timing synchronizer.
    """
  return _gnuradio_core_filter.pfb_clock_sync_fff(*args, **kwargs)
class gr_dc_blocker_cc_sptr(object):
    """Proxy of C++ boost::shared_ptr<(gr_dc_blocker_cc)> class"""
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(self) -> gr_dc_blocker_cc_sptr
        __init__(self,  p) -> gr_dc_blocker_cc_sptr
        """
        this = _gnuradio_core_filter.new_gr_dc_blocker_cc_sptr(*args)
        try: self.this.append(this)
        except: self.this = this
    def __deref__(self):
        """__deref__(self)"""
        return _gnuradio_core_filter.gr_dc_blocker_cc_sptr___deref__(self)

    __swig_destroy__ = _gnuradio_core_filter.delete_gr_dc_blocker_cc_sptr
    __del__ = lambda self : None;
    def history(self):
        """history(self) -> unsigned int"""
        return _gnuradio_core_filter.gr_dc_blocker_cc_sptr_history(self)

    def output_multiple(self):
        """output_multiple(self) -> int"""
        return _gnuradio_core_filter.gr_dc_blocker_cc_sptr_output_multiple(self)

    def relative_rate(self):
        """relative_rate(self) -> double"""
        return _gnuradio_core_filter.gr_dc_blocker_cc_sptr_relative_rate(self)

    def start(self):
        """start(self) -> bool"""
        return _gnuradio_core_filter.gr_dc_blocker_cc_sptr_start(self)

    def stop(self):
        """stop(self) -> bool"""
        return _gnuradio_core_filter.gr_dc_blocker_cc_sptr_stop(self)

    def nitems_read(self, *args, **kwargs):
        """nitems_read(self, unsigned int which_input) -> uint64_t"""
        return _gnuradio_core_filter.gr_dc_blocker_cc_sptr_nitems_read(self, *args, **kwargs)

    def nitems_written(self, *args, **kwargs):
        """nitems_written(self, unsigned int which_output) -> uint64_t"""
        return _gnuradio_core_filter.gr_dc_blocker_cc_sptr_nitems_written(self, *args, **kwargs)

    def detail(self):
        """detail(self) -> gr_block_detail_sptr"""
        return _gnuradio_core_filter.gr_dc_blocker_cc_sptr_detail(self)

    def set_detail(self, *args, **kwargs):
        """set_detail(self, gr_block_detail_sptr detail)"""
        return _gnuradio_core_filter.gr_dc_blocker_cc_sptr_set_detail(self, *args, **kwargs)

    def name(self):
        """name(self) -> string"""
        return _gnuradio_core_filter.gr_dc_blocker_cc_sptr_name(self)

    def input_signature(self):
        """input_signature(self) -> gr_io_signature_sptr"""
        return _gnuradio_core_filter.gr_dc_blocker_cc_sptr_input_signature(self)

    def output_signature(self):
        """output_signature(self) -> gr_io_signature_sptr"""
        return _gnuradio_core_filter.gr_dc_blocker_cc_sptr_output_signature(self)

    def unique_id(self):
        """unique_id(self) -> long"""
        return _gnuradio_core_filter.gr_dc_blocker_cc_sptr_unique_id(self)

    def to_basic_block(self):
        """to_basic_block(self) -> gr_basic_block_sptr"""
        return _gnuradio_core_filter.gr_dc_blocker_cc_sptr_to_basic_block(self)

    def check_topology(self, *args, **kwargs):
        """check_topology(self, int ninputs, int noutputs) -> bool"""
        return _gnuradio_core_filter.gr_dc_blocker_cc_sptr_check_topology(self, *args, **kwargs)

gr_dc_blocker_cc_sptr_swigregister = _gnuradio_core_filter.gr_dc_blocker_cc_sptr_swigregister
gr_dc_blocker_cc_sptr_swigregister(gr_dc_blocker_cc_sptr)

gr_dc_blocker_cc_sptr.__repr__ = lambda self: "<gr_block %s (%d)>" % (self.name(), self.unique_id ())


def dc_blocker_cc(D = 32, long_form = True):
  """
    dc_blocker_cc(int D = 32, bool long_form = True) -> gr_dc_blocker_cc_sptr

    a computationally efficient controllable DC blocker

    This block implements a computationally efficient DC blocker that produces a tighter notch filter around DC for a smaller group delay than an equivalent FIR filter or using a single pole IIR filter (though the IIR filter is computationally cheaper).

    The block defaults to using a delay line of length 32 and the long form of the filter. Optionally, the delay line length can be changed to alter the width of the DC notch (longer lines will decrease the width).

    The long form of the filter produces a nearly flat response outside of the notch but at the cost of a group delay of 2D-2.

    The short form of the filter does not have as flat a response in the passband but has a group delay of only D-1 and is cheaper to compute.

    The theory behind this block can be found in the paper:

    Build the DC blocker.
    """
  return _gnuradio_core_filter.dc_blocker_cc(D, long_form)
class gr_dc_blocker_ff_sptr(object):
    """Proxy of C++ boost::shared_ptr<(gr_dc_blocker_ff)> class"""
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(self) -> gr_dc_blocker_ff_sptr
        __init__(self,  p) -> gr_dc_blocker_ff_sptr
        """
        this = _gnuradio_core_filter.new_gr_dc_blocker_ff_sptr(*args)
        try: self.this.append(this)
        except: self.this = this
    def __deref__(self):
        """__deref__(self)"""
        return _gnuradio_core_filter.gr_dc_blocker_ff_sptr___deref__(self)

    __swig_destroy__ = _gnuradio_core_filter.delete_gr_dc_blocker_ff_sptr
    __del__ = lambda self : None;
    def history(self):
        """history(self) -> unsigned int"""
        return _gnuradio_core_filter.gr_dc_blocker_ff_sptr_history(self)

    def output_multiple(self):
        """output_multiple(self) -> int"""
        return _gnuradio_core_filter.gr_dc_blocker_ff_sptr_output_multiple(self)

    def relative_rate(self):
        """relative_rate(self) -> double"""
        return _gnuradio_core_filter.gr_dc_blocker_ff_sptr_relative_rate(self)

    def start(self):
        """start(self) -> bool"""
        return _gnuradio_core_filter.gr_dc_blocker_ff_sptr_start(self)

    def stop(self):
        """stop(self) -> bool"""
        return _gnuradio_core_filter.gr_dc_blocker_ff_sptr_stop(self)

    def nitems_read(self, *args, **kwargs):
        """nitems_read(self, unsigned int which_input) -> uint64_t"""
        return _gnuradio_core_filter.gr_dc_blocker_ff_sptr_nitems_read(self, *args, **kwargs)

    def nitems_written(self, *args, **kwargs):
        """nitems_written(self, unsigned int which_output) -> uint64_t"""
        return _gnuradio_core_filter.gr_dc_blocker_ff_sptr_nitems_written(self, *args, **kwargs)

    def detail(self):
        """detail(self) -> gr_block_detail_sptr"""
        return _gnuradio_core_filter.gr_dc_blocker_ff_sptr_detail(self)

    def set_detail(self, *args, **kwargs):
        """set_detail(self, gr_block_detail_sptr detail)"""
        return _gnuradio_core_filter.gr_dc_blocker_ff_sptr_set_detail(self, *args, **kwargs)

    def name(self):
        """name(self) -> string"""
        return _gnuradio_core_filter.gr_dc_blocker_ff_sptr_name(self)

    def input_signature(self):
        """input_signature(self) -> gr_io_signature_sptr"""
        return _gnuradio_core_filter.gr_dc_blocker_ff_sptr_input_signature(self)

    def output_signature(self):
        """output_signature(self) -> gr_io_signature_sptr"""
        return _gnuradio_core_filter.gr_dc_blocker_ff_sptr_output_signature(self)

    def unique_id(self):
        """unique_id(self) -> long"""
        return _gnuradio_core_filter.gr_dc_blocker_ff_sptr_unique_id(self)

    def to_basic_block(self):
        """to_basic_block(self) -> gr_basic_block_sptr"""
        return _gnuradio_core_filter.gr_dc_blocker_ff_sptr_to_basic_block(self)

    def check_topology(self, *args, **kwargs):
        """check_topology(self, int ninputs, int noutputs) -> bool"""
        return _gnuradio_core_filter.gr_dc_blocker_ff_sptr_check_topology(self, *args, **kwargs)

gr_dc_blocker_ff_sptr_swigregister = _gnuradio_core_filter.gr_dc_blocker_ff_sptr_swigregister
gr_dc_blocker_ff_sptr_swigregister(gr_dc_blocker_ff_sptr)

gr_dc_blocker_ff_sptr.__repr__ = lambda self: "<gr_block %s (%d)>" % (self.name(), self.unique_id ())


def dc_blocker_ff(D = 32, long_form = True):
  """
    dc_blocker_ff(int D = 32, bool long_form = True) -> gr_dc_blocker_ff_sptr

    a computationally efficient controllable DC blocker

    This block implements a computationally efficient DC blocker that produces a tighter notch filter around DC for a smaller group delay than an equivalent FIR filter or using a single pole IIR filter (though the IIR filter is computationally cheaper).

    The block defaults to using a delay line of length 32 and the long form of the filter. Optionally, the delay line length can be changed to alter the width of the DC notch (longer lines will decrease the width).

    The long form of the filter produces a nearly flat response outside of the notch but at the cost of a group delay of 2D-2.

    The short form of the filter does not have as flat a response in the passband but has a group delay of only D-1 and is cheaper to compute.

    The theory behind this block can be found in the paper:

    Build the DC blocker.
    """
  return _gnuradio_core_filter.dc_blocker_ff(D, long_form)
class gr_fir_filter_ccc_sptr(object):
    """Proxy of C++ boost::shared_ptr<(gr_fir_filter_ccc)> class"""
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(self) -> gr_fir_filter_ccc_sptr
        __init__(self,  p) -> gr_fir_filter_ccc_sptr
        """
        this = _gnuradio_core_filter.new_gr_fir_filter_ccc_sptr(*args)
        try: self.this.append(this)
        except: self.this = this
    def __deref__(self):
        """__deref__(self)"""
        return _gnuradio_core_filter.gr_fir_filter_ccc_sptr___deref__(self)

    __swig_destroy__ = _gnuradio_core_filter.delete_gr_fir_filter_ccc_sptr
    __del__ = lambda self : None;
    def set_taps(self, *args, **kwargs):
        """set_taps(self, std::vector<(gr_complex,std::allocator<(gr_complex)>)> taps)"""
        return _gnuradio_core_filter.gr_fir_filter_ccc_sptr_set_taps(self, *args, **kwargs)

    def taps(self):
        """taps(self) -> std::vector<(gr_complex,std::allocator<(gr_complex)>)>"""
        return _gnuradio_core_filter.gr_fir_filter_ccc_sptr_taps(self)

    def history(self):
        """history(self) -> unsigned int"""
        return _gnuradio_core_filter.gr_fir_filter_ccc_sptr_history(self)

    def output_multiple(self):
        """output_multiple(self) -> int"""
        return _gnuradio_core_filter.gr_fir_filter_ccc_sptr_output_multiple(self)

    def relative_rate(self):
        """relative_rate(self) -> double"""
        return _gnuradio_core_filter.gr_fir_filter_ccc_sptr_relative_rate(self)

    def start(self):
        """start(self) -> bool"""
        return _gnuradio_core_filter.gr_fir_filter_ccc_sptr_start(self)

    def stop(self):
        """stop(self) -> bool"""
        return _gnuradio_core_filter.gr_fir_filter_ccc_sptr_stop(self)

    def nitems_read(self, *args, **kwargs):
        """nitems_read(self, unsigned int which_input) -> uint64_t"""
        return _gnuradio_core_filter.gr_fir_filter_ccc_sptr_nitems_read(self, *args, **kwargs)

    def nitems_written(self, *args, **kwargs):
        """nitems_written(self, unsigned int which_output) -> uint64_t"""
        return _gnuradio_core_filter.gr_fir_filter_ccc_sptr_nitems_written(self, *args, **kwargs)

    def detail(self):
        """detail(self) -> gr_block_detail_sptr"""
        return _gnuradio_core_filter.gr_fir_filter_ccc_sptr_detail(self)

    def set_detail(self, *args, **kwargs):
        """set_detail(self, gr_block_detail_sptr detail)"""
        return _gnuradio_core_filter.gr_fir_filter_ccc_sptr_set_detail(self, *args, **kwargs)

    def name(self):
        """name(self) -> string"""
        return _gnuradio_core_filter.gr_fir_filter_ccc_sptr_name(self)

    def input_signature(self):
        """input_signature(self) -> gr_io_signature_sptr"""
        return _gnuradio_core_filter.gr_fir_filter_ccc_sptr_input_signature(self)

    def output_signature(self):
        """output_signature(self) -> gr_io_signature_sptr"""
        return _gnuradio_core_filter.gr_fir_filter_ccc_sptr_output_signature(self)

    def unique_id(self):
        """unique_id(self) -> long"""
        return _gnuradio_core_filter.gr_fir_filter_ccc_sptr_unique_id(self)

    def to_basic_block(self):
        """to_basic_block(self) -> gr_basic_block_sptr"""
        return _gnuradio_core_filter.gr_fir_filter_ccc_sptr_to_basic_block(self)

    def check_topology(self, *args, **kwargs):
        """check_topology(self, int ninputs, int noutputs) -> bool"""
        return _gnuradio_core_filter.gr_fir_filter_ccc_sptr_check_topology(self, *args, **kwargs)

gr_fir_filter_ccc_sptr_swigregister = _gnuradio_core_filter.gr_fir_filter_ccc_sptr_swigregister
gr_fir_filter_ccc_sptr_swigregister(gr_fir_filter_ccc_sptr)

gr_fir_filter_ccc_sptr.__repr__ = lambda self: "<gr_block %s (%d)>" % (self.name(), self.unique_id ())


def fir_filter_ccc(*args, **kwargs):
  """
    fir_filter_ccc(int decimation, std::vector<(gr_complex,std::allocator<(gr_complex)>)> taps) -> gr_fir_filter_ccc_sptr

    FIR filter with gr_complex input, gr_complex output and gr_complex taps.
    """
  return _gnuradio_core_filter.fir_filter_ccc(*args, **kwargs)
class gr_fir_filter_ccf_sptr(object):
    """Proxy of C++ boost::shared_ptr<(gr_fir_filter_ccf)> class"""
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(self) -> gr_fir_filter_ccf_sptr
        __init__(self,  p) -> gr_fir_filter_ccf_sptr
        """
        this = _gnuradio_core_filter.new_gr_fir_filter_ccf_sptr(*args)
        try: self.this.append(this)
        except: self.this = this
    def __deref__(self):
        """__deref__(self)"""
        return _gnuradio_core_filter.gr_fir_filter_ccf_sptr___deref__(self)

    __swig_destroy__ = _gnuradio_core_filter.delete_gr_fir_filter_ccf_sptr
    __del__ = lambda self : None;
    def set_taps(self, *args, **kwargs):
        """set_taps(self, __dummy_4__ taps)"""
        return _gnuradio_core_filter.gr_fir_filter_ccf_sptr_set_taps(self, *args, **kwargs)

    def taps(self):
        """taps(self) -> __dummy_4__"""
        return _gnuradio_core_filter.gr_fir_filter_ccf_sptr_taps(self)

    def history(self):
        """history(self) -> unsigned int"""
        return _gnuradio_core_filter.gr_fir_filter_ccf_sptr_history(self)

    def output_multiple(self):
        """output_multiple(self) -> int"""
        return _gnuradio_core_filter.gr_fir_filter_ccf_sptr_output_multiple(self)

    def relative_rate(self):
        """relative_rate(self) -> double"""
        return _gnuradio_core_filter.gr_fir_filter_ccf_sptr_relative_rate(self)

    def start(self):
        """start(self) -> bool"""
        return _gnuradio_core_filter.gr_fir_filter_ccf_sptr_start(self)

    def stop(self):
        """stop(self) -> bool"""
        return _gnuradio_core_filter.gr_fir_filter_ccf_sptr_stop(self)

    def nitems_read(self, *args, **kwargs):
        """nitems_read(self, unsigned int which_input) -> uint64_t"""
        return _gnuradio_core_filter.gr_fir_filter_ccf_sptr_nitems_read(self, *args, **kwargs)

    def nitems_written(self, *args, **kwargs):
        """nitems_written(self, unsigned int which_output) -> uint64_t"""
        return _gnuradio_core_filter.gr_fir_filter_ccf_sptr_nitems_written(self, *args, **kwargs)

    def detail(self):
        """detail(self) -> gr_block_detail_sptr"""
        return _gnuradio_core_filter.gr_fir_filter_ccf_sptr_detail(self)

    def set_detail(self, *args, **kwargs):
        """set_detail(self, gr_block_detail_sptr detail)"""
        return _gnuradio_core_filter.gr_fir_filter_ccf_sptr_set_detail(self, *args, **kwargs)

    def name(self):
        """name(self) -> string"""
        return _gnuradio_core_filter.gr_fir_filter_ccf_sptr_name(self)

    def input_signature(self):
        """input_signature(self) -> gr_io_signature_sptr"""
        return _gnuradio_core_filter.gr_fir_filter_ccf_sptr_input_signature(self)

    def output_signature(self):
        """output_signature(self) -> gr_io_signature_sptr"""
        return _gnuradio_core_filter.gr_fir_filter_ccf_sptr_output_signature(self)

    def unique_id(self):
        """unique_id(self) -> long"""
        return _gnuradio_core_filter.gr_fir_filter_ccf_sptr_unique_id(self)

    def to_basic_block(self):
        """to_basic_block(self) -> gr_basic_block_sptr"""
        return _gnuradio_core_filter.gr_fir_filter_ccf_sptr_to_basic_block(self)

    def check_topology(self, *args, **kwargs):
        """check_topology(self, int ninputs, int noutputs) -> bool"""
        return _gnuradio_core_filter.gr_fir_filter_ccf_sptr_check_topology(self, *args, **kwargs)

gr_fir_filter_ccf_sptr_swigregister = _gnuradio_core_filter.gr_fir_filter_ccf_sptr_swigregister
gr_fir_filter_ccf_sptr_swigregister(gr_fir_filter_ccf_sptr)

gr_fir_filter_ccf_sptr.__repr__ = lambda self: "<gr_block %s (%d)>" % (self.name(), self.unique_id ())


def fir_filter_ccf(*args, **kwargs):
  """
    fir_filter_ccf(int decimation, __dummy_4__ taps) -> gr_fir_filter_ccf_sptr

    FIR filter with gr_complex input, gr_complex output and float taps.
    """
  return _gnuradio_core_filter.fir_filter_ccf(*args, **kwargs)
class gr_fir_filter_fcc_sptr(object):
    """Proxy of C++ boost::shared_ptr<(gr_fir_filter_fcc)> class"""
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(self) -> gr_fir_filter_fcc_sptr
        __init__(self,  p) -> gr_fir_filter_fcc_sptr
        """
        this = _gnuradio_core_filter.new_gr_fir_filter_fcc_sptr(*args)
        try: self.this.append(this)
        except: self.this = this
    def __deref__(self):
        """__deref__(self)"""
        return _gnuradio_core_filter.gr_fir_filter_fcc_sptr___deref__(self)

    __swig_destroy__ = _gnuradio_core_filter.delete_gr_fir_filter_fcc_sptr
    __del__ = lambda self : None;
    def set_taps(self, *args, **kwargs):
        """set_taps(self, std::vector<(gr_complex,std::allocator<(gr_complex)>)> taps)"""
        return _gnuradio_core_filter.gr_fir_filter_fcc_sptr_set_taps(self, *args, **kwargs)

    def taps(self):
        """taps(self) -> std::vector<(gr_complex,std::allocator<(gr_complex)>)>"""
        return _gnuradio_core_filter.gr_fir_filter_fcc_sptr_taps(self)

    def history(self):
        """history(self) -> unsigned int"""
        return _gnuradio_core_filter.gr_fir_filter_fcc_sptr_history(self)

    def output_multiple(self):
        """output_multiple(self) -> int"""
        return _gnuradio_core_filter.gr_fir_filter_fcc_sptr_output_multiple(self)

    def relative_rate(self):
        """relative_rate(self) -> double"""
        return _gnuradio_core_filter.gr_fir_filter_fcc_sptr_relative_rate(self)

    def start(self):
        """start(self) -> bool"""
        return _gnuradio_core_filter.gr_fir_filter_fcc_sptr_start(self)

    def stop(self):
        """stop(self) -> bool"""
        return _gnuradio_core_filter.gr_fir_filter_fcc_sptr_stop(self)

    def nitems_read(self, *args, **kwargs):
        """nitems_read(self, unsigned int which_input) -> uint64_t"""
        return _gnuradio_core_filter.gr_fir_filter_fcc_sptr_nitems_read(self, *args, **kwargs)

    def nitems_written(self, *args, **kwargs):
        """nitems_written(self, unsigned int which_output) -> uint64_t"""
        return _gnuradio_core_filter.gr_fir_filter_fcc_sptr_nitems_written(self, *args, **kwargs)

    def detail(self):
        """detail(self) -> gr_block_detail_sptr"""
        return _gnuradio_core_filter.gr_fir_filter_fcc_sptr_detail(self)

    def set_detail(self, *args, **kwargs):
        """set_detail(self, gr_block_detail_sptr detail)"""
        return _gnuradio_core_filter.gr_fir_filter_fcc_sptr_set_detail(self, *args, **kwargs)

    def name(self):
        """name(self) -> string"""
        return _gnuradio_core_filter.gr_fir_filter_fcc_sptr_name(self)

    def input_signature(self):
        """input_signature(self) -> gr_io_signature_sptr"""
        return _gnuradio_core_filter.gr_fir_filter_fcc_sptr_input_signature(self)

    def output_signature(self):
        """output_signature(self) -> gr_io_signature_sptr"""
        return _gnuradio_core_filter.gr_fir_filter_fcc_sptr_output_signature(self)

    def unique_id(self):
        """unique_id(self) -> long"""
        return _gnuradio_core_filter.gr_fir_filter_fcc_sptr_unique_id(self)

    def to_basic_block(self):
        """to_basic_block(self) -> gr_basic_block_sptr"""
        return _gnuradio_core_filter.gr_fir_filter_fcc_sptr_to_basic_block(self)

    def check_topology(self, *args, **kwargs):
        """check_topology(self, int ninputs, int noutputs) -> bool"""
        return _gnuradio_core_filter.gr_fir_filter_fcc_sptr_check_topology(self, *args, **kwargs)

gr_fir_filter_fcc_sptr_swigregister = _gnuradio_core_filter.gr_fir_filter_fcc_sptr_swigregister
gr_fir_filter_fcc_sptr_swigregister(gr_fir_filter_fcc_sptr)

gr_fir_filter_fcc_sptr.__repr__ = lambda self: "<gr_block %s (%d)>" % (self.name(), self.unique_id ())


def fir_filter_fcc(*args, **kwargs):
  """
    fir_filter_fcc(int decimation, std::vector<(gr_complex,std::allocator<(gr_complex)>)> taps) -> gr_fir_filter_fcc_sptr

    FIR filter with float input, gr_complex output and gr_complex taps.
    """
  return _gnuradio_core_filter.fir_filter_fcc(*args, **kwargs)
class gr_fir_filter_fff_sptr(object):
    """Proxy of C++ boost::shared_ptr<(gr_fir_filter_fff)> class"""
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(self) -> gr_fir_filter_fff_sptr
        __init__(self,  p) -> gr_fir_filter_fff_sptr
        """
        this = _gnuradio_core_filter.new_gr_fir_filter_fff_sptr(*args)
        try: self.this.append(this)
        except: self.this = this
    def __deref__(self):
        """__deref__(self)"""
        return _gnuradio_core_filter.gr_fir_filter_fff_sptr___deref__(self)

    __swig_destroy__ = _gnuradio_core_filter.delete_gr_fir_filter_fff_sptr
    __del__ = lambda self : None;
    def set_taps(self, *args, **kwargs):
        """set_taps(self, __dummy_4__ taps)"""
        return _gnuradio_core_filter.gr_fir_filter_fff_sptr_set_taps(self, *args, **kwargs)

    def taps(self):
        """taps(self) -> __dummy_4__"""
        return _gnuradio_core_filter.gr_fir_filter_fff_sptr_taps(self)

    def history(self):
        """history(self) -> unsigned int"""
        return _gnuradio_core_filter.gr_fir_filter_fff_sptr_history(self)

    def output_multiple(self):
        """output_multiple(self) -> int"""
        return _gnuradio_core_filter.gr_fir_filter_fff_sptr_output_multiple(self)

    def relative_rate(self):
        """relative_rate(self) -> double"""
        return _gnuradio_core_filter.gr_fir_filter_fff_sptr_relative_rate(self)

    def start(self):
        """start(self) -> bool"""
        return _gnuradio_core_filter.gr_fir_filter_fff_sptr_start(self)

    def stop(self):
        """stop(self) -> bool"""
        return _gnuradio_core_filter.gr_fir_filter_fff_sptr_stop(self)

    def nitems_read(self, *args, **kwargs):
        """nitems_read(self, unsigned int which_input) -> uint64_t"""
        return _gnuradio_core_filter.gr_fir_filter_fff_sptr_nitems_read(self, *args, **kwargs)

    def nitems_written(self, *args, **kwargs):
        """nitems_written(self, unsigned int which_output) -> uint64_t"""
        return _gnuradio_core_filter.gr_fir_filter_fff_sptr_nitems_written(self, *args, **kwargs)

    def detail(self):
        """detail(self) -> gr_block_detail_sptr"""
        return _gnuradio_core_filter.gr_fir_filter_fff_sptr_detail(self)

    def set_detail(self, *args, **kwargs):
        """set_detail(self, gr_block_detail_sptr detail)"""
        return _gnuradio_core_filter.gr_fir_filter_fff_sptr_set_detail(self, *args, **kwargs)

    def name(self):
        """name(self) -> string"""
        return _gnuradio_core_filter.gr_fir_filter_fff_sptr_name(self)

    def input_signature(self):
        """input_signature(self) -> gr_io_signature_sptr"""
        return _gnuradio_core_filter.gr_fir_filter_fff_sptr_input_signature(self)

    def output_signature(self):
        """output_signature(self) -> gr_io_signature_sptr"""
        return _gnuradio_core_filter.gr_fir_filter_fff_sptr_output_signature(self)

    def unique_id(self):
        """unique_id(self) -> long"""
        return _gnuradio_core_filter.gr_fir_filter_fff_sptr_unique_id(self)

    def to_basic_block(self):
        """to_basic_block(self) -> gr_basic_block_sptr"""
        return _gnuradio_core_filter.gr_fir_filter_fff_sptr_to_basic_block(self)

    def check_topology(self, *args, **kwargs):
        """check_topology(self, int ninputs, int noutputs) -> bool"""
        return _gnuradio_core_filter.gr_fir_filter_fff_sptr_check_topology(self, *args, **kwargs)

gr_fir_filter_fff_sptr_swigregister = _gnuradio_core_filter.gr_fir_filter_fff_sptr_swigregister
gr_fir_filter_fff_sptr_swigregister(gr_fir_filter_fff_sptr)

gr_fir_filter_fff_sptr.__repr__ = lambda self: "<gr_block %s (%d)>" % (self.name(), self.unique_id ())


def fir_filter_fff(*args, **kwargs):
  """
    fir_filter_fff(int decimation, __dummy_4__ taps) -> gr_fir_filter_fff_sptr

    FIR filter with float input, float output and float taps.
    """
  return _gnuradio_core_filter.fir_filter_fff(*args, **kwargs)
class gr_fir_filter_fsf_sptr(object):
    """Proxy of C++ boost::shared_ptr<(gr_fir_filter_fsf)> class"""
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(self) -> gr_fir_filter_fsf_sptr
        __init__(self,  p) -> gr_fir_filter_fsf_sptr
        """
        this = _gnuradio_core_filter.new_gr_fir_filter_fsf_sptr(*args)
        try: self.this.append(this)
        except: self.this = this
    def __deref__(self):
        """__deref__(self)"""
        return _gnuradio_core_filter.gr_fir_filter_fsf_sptr___deref__(self)

    __swig_destroy__ = _gnuradio_core_filter.delete_gr_fir_filter_fsf_sptr
    __del__ = lambda self : None;
    def set_taps(self, *args, **kwargs):
        """set_taps(self, __dummy_4__ taps)"""
        return _gnuradio_core_filter.gr_fir_filter_fsf_sptr_set_taps(self, *args, **kwargs)

    def taps(self):
        """taps(self) -> __dummy_4__"""
        return _gnuradio_core_filter.gr_fir_filter_fsf_sptr_taps(self)

    def history(self):
        """history(self) -> unsigned int"""
        return _gnuradio_core_filter.gr_fir_filter_fsf_sptr_history(self)

    def output_multiple(self):
        """output_multiple(self) -> int"""
        return _gnuradio_core_filter.gr_fir_filter_fsf_sptr_output_multiple(self)

    def relative_rate(self):
        """relative_rate(self) -> double"""
        return _gnuradio_core_filter.gr_fir_filter_fsf_sptr_relative_rate(self)

    def start(self):
        """start(self) -> bool"""
        return _gnuradio_core_filter.gr_fir_filter_fsf_sptr_start(self)

    def stop(self):
        """stop(self) -> bool"""
        return _gnuradio_core_filter.gr_fir_filter_fsf_sptr_stop(self)

    def nitems_read(self, *args, **kwargs):
        """nitems_read(self, unsigned int which_input) -> uint64_t"""
        return _gnuradio_core_filter.gr_fir_filter_fsf_sptr_nitems_read(self, *args, **kwargs)

    def nitems_written(self, *args, **kwargs):
        """nitems_written(self, unsigned int which_output) -> uint64_t"""
        return _gnuradio_core_filter.gr_fir_filter_fsf_sptr_nitems_written(self, *args, **kwargs)

    def detail(self):
        """detail(self) -> gr_block_detail_sptr"""
        return _gnuradio_core_filter.gr_fir_filter_fsf_sptr_detail(self)

    def set_detail(self, *args, **kwargs):
        """set_detail(self, gr_block_detail_sptr detail)"""
        return _gnuradio_core_filter.gr_fir_filter_fsf_sptr_set_detail(self, *args, **kwargs)

    def name(self):
        """name(self) -> string"""
        return _gnuradio_core_filter.gr_fir_filter_fsf_sptr_name(self)

    def input_signature(self):
        """input_signature(self) -> gr_io_signature_sptr"""
        return _gnuradio_core_filter.gr_fir_filter_fsf_sptr_input_signature(self)

    def output_signature(self):
        """output_signature(self) -> gr_io_signature_sptr"""
        return _gnuradio_core_filter.gr_fir_filter_fsf_sptr_output_signature(self)

    def unique_id(self):
        """unique_id(self) -> long"""
        return _gnuradio_core_filter.gr_fir_filter_fsf_sptr_unique_id(self)

    def to_basic_block(self):
        """to_basic_block(self) -> gr_basic_block_sptr"""
        return _gnuradio_core_filter.gr_fir_filter_fsf_sptr_to_basic_block(self)

    def check_topology(self, *args, **kwargs):
        """check_topology(self, int ninputs, int noutputs) -> bool"""
        return _gnuradio_core_filter.gr_fir_filter_fsf_sptr_check_topology(self, *args, **kwargs)

gr_fir_filter_fsf_sptr_swigregister = _gnuradio_core_filter.gr_fir_filter_fsf_sptr_swigregister
gr_fir_filter_fsf_sptr_swigregister(gr_fir_filter_fsf_sptr)

gr_fir_filter_fsf_sptr.__repr__ = lambda self: "<gr_block %s (%d)>" % (self.name(), self.unique_id ())


def fir_filter_fsf(*args, **kwargs):
  """
    fir_filter_fsf(int decimation, __dummy_4__ taps) -> gr_fir_filter_fsf_sptr

    FIR filter with float input, short output and float taps.
    """
  return _gnuradio_core_filter.fir_filter_fsf(*args, **kwargs)
class gr_fir_filter_scc_sptr(object):
    """Proxy of C++ boost::shared_ptr<(gr_fir_filter_scc)> class"""
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(self) -> gr_fir_filter_scc_sptr
        __init__(self,  p) -> gr_fir_filter_scc_sptr
        """
        this = _gnuradio_core_filter.new_gr_fir_filter_scc_sptr(*args)
        try: self.this.append(this)
        except: self.this = this
    def __deref__(self):
        """__deref__(self)"""
        return _gnuradio_core_filter.gr_fir_filter_scc_sptr___deref__(self)

    __swig_destroy__ = _gnuradio_core_filter.delete_gr_fir_filter_scc_sptr
    __del__ = lambda self : None;
    def set_taps(self, *args, **kwargs):
        """set_taps(self, std::vector<(gr_complex,std::allocator<(gr_complex)>)> taps)"""
        return _gnuradio_core_filter.gr_fir_filter_scc_sptr_set_taps(self, *args, **kwargs)

    def taps(self):
        """taps(self) -> std::vector<(gr_complex,std::allocator<(gr_complex)>)>"""
        return _gnuradio_core_filter.gr_fir_filter_scc_sptr_taps(self)

    def history(self):
        """history(self) -> unsigned int"""
        return _gnuradio_core_filter.gr_fir_filter_scc_sptr_history(self)

    def output_multiple(self):
        """output_multiple(self) -> int"""
        return _gnuradio_core_filter.gr_fir_filter_scc_sptr_output_multiple(self)

    def relative_rate(self):
        """relative_rate(self) -> double"""
        return _gnuradio_core_filter.gr_fir_filter_scc_sptr_relative_rate(self)

    def start(self):
        """start(self) -> bool"""
        return _gnuradio_core_filter.gr_fir_filter_scc_sptr_start(self)

    def stop(self):
        """stop(self) -> bool"""
        return _gnuradio_core_filter.gr_fir_filter_scc_sptr_stop(self)

    def nitems_read(self, *args, **kwargs):
        """nitems_read(self, unsigned int which_input) -> uint64_t"""
        return _gnuradio_core_filter.gr_fir_filter_scc_sptr_nitems_read(self, *args, **kwargs)

    def nitems_written(self, *args, **kwargs):
        """nitems_written(self, unsigned int which_output) -> uint64_t"""
        return _gnuradio_core_filter.gr_fir_filter_scc_sptr_nitems_written(self, *args, **kwargs)

    def detail(self):
        """detail(self) -> gr_block_detail_sptr"""
        return _gnuradio_core_filter.gr_fir_filter_scc_sptr_detail(self)

    def set_detail(self, *args, **kwargs):
        """set_detail(self, gr_block_detail_sptr detail)"""
        return _gnuradio_core_filter.gr_fir_filter_scc_sptr_set_detail(self, *args, **kwargs)

    def name(self):
        """name(self) -> string"""
        return _gnuradio_core_filter.gr_fir_filter_scc_sptr_name(self)

    def input_signature(self):
        """input_signature(self) -> gr_io_signature_sptr"""
        return _gnuradio_core_filter.gr_fir_filter_scc_sptr_input_signature(self)

    def output_signature(self):
        """output_signature(self) -> gr_io_signature_sptr"""
        return _gnuradio_core_filter.gr_fir_filter_scc_sptr_output_signature(self)

    def unique_id(self):
        """unique_id(self) -> long"""
        return _gnuradio_core_filter.gr_fir_filter_scc_sptr_unique_id(self)

    def to_basic_block(self):
        """to_basic_block(self) -> gr_basic_block_sptr"""
        return _gnuradio_core_filter.gr_fir_filter_scc_sptr_to_basic_block(self)

    def check_topology(self, *args, **kwargs):
        """check_topology(self, int ninputs, int noutputs) -> bool"""
        return _gnuradio_core_filter.gr_fir_filter_scc_sptr_check_topology(self, *args, **kwargs)

gr_fir_filter_scc_sptr_swigregister = _gnuradio_core_filter.gr_fir_filter_scc_sptr_swigregister
gr_fir_filter_scc_sptr_swigregister(gr_fir_filter_scc_sptr)

gr_fir_filter_scc_sptr.__repr__ = lambda self: "<gr_block %s (%d)>" % (self.name(), self.unique_id ())


def fir_filter_scc(*args, **kwargs):
  """
    fir_filter_scc(int decimation, std::vector<(gr_complex,std::allocator<(gr_complex)>)> taps) -> gr_fir_filter_scc_sptr

    FIR filter with short input, gr_complex output and gr_complex taps.
    """
  return _gnuradio_core_filter.fir_filter_scc(*args, **kwargs)
class gr_freq_xlating_fir_filter_ccc_sptr(object):
    """Proxy of C++ boost::shared_ptr<(gr_freq_xlating_fir_filter_ccc)> class"""
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(self) -> gr_freq_xlating_fir_filter_ccc_sptr
        __init__(self,  p) -> gr_freq_xlating_fir_filter_ccc_sptr
        """
        this = _gnuradio_core_filter.new_gr_freq_xlating_fir_filter_ccc_sptr(*args)
        try: self.this.append(this)
        except: self.this = this
    def __deref__(self):
        """__deref__(self)"""
        return _gnuradio_core_filter.gr_freq_xlating_fir_filter_ccc_sptr___deref__(self)

    __swig_destroy__ = _gnuradio_core_filter.delete_gr_freq_xlating_fir_filter_ccc_sptr
    __del__ = lambda self : None;
    def set_center_freq(self, *args, **kwargs):
        """set_center_freq(self, double center_freq)"""
        return _gnuradio_core_filter.gr_freq_xlating_fir_filter_ccc_sptr_set_center_freq(self, *args, **kwargs)

    def set_taps(self, *args, **kwargs):
        """set_taps(self, std::vector<(gr_complex,std::allocator<(gr_complex)>)> taps)"""
        return _gnuradio_core_filter.gr_freq_xlating_fir_filter_ccc_sptr_set_taps(self, *args, **kwargs)

    def history(self):
        """history(self) -> unsigned int"""
        return _gnuradio_core_filter.gr_freq_xlating_fir_filter_ccc_sptr_history(self)

    def output_multiple(self):
        """output_multiple(self) -> int"""
        return _gnuradio_core_filter.gr_freq_xlating_fir_filter_ccc_sptr_output_multiple(self)

    def relative_rate(self):
        """relative_rate(self) -> double"""
        return _gnuradio_core_filter.gr_freq_xlating_fir_filter_ccc_sptr_relative_rate(self)

    def start(self):
        """start(self) -> bool"""
        return _gnuradio_core_filter.gr_freq_xlating_fir_filter_ccc_sptr_start(self)

    def stop(self):
        """stop(self) -> bool"""
        return _gnuradio_core_filter.gr_freq_xlating_fir_filter_ccc_sptr_stop(self)

    def nitems_read(self, *args, **kwargs):
        """nitems_read(self, unsigned int which_input) -> uint64_t"""
        return _gnuradio_core_filter.gr_freq_xlating_fir_filter_ccc_sptr_nitems_read(self, *args, **kwargs)

    def nitems_written(self, *args, **kwargs):
        """nitems_written(self, unsigned int which_output) -> uint64_t"""
        return _gnuradio_core_filter.gr_freq_xlating_fir_filter_ccc_sptr_nitems_written(self, *args, **kwargs)

    def detail(self):
        """detail(self) -> gr_block_detail_sptr"""
        return _gnuradio_core_filter.gr_freq_xlating_fir_filter_ccc_sptr_detail(self)

    def set_detail(self, *args, **kwargs):
        """set_detail(self, gr_block_detail_sptr detail)"""
        return _gnuradio_core_filter.gr_freq_xlating_fir_filter_ccc_sptr_set_detail(self, *args, **kwargs)

    def name(self):
        """name(self) -> string"""
        return _gnuradio_core_filter.gr_freq_xlating_fir_filter_ccc_sptr_name(self)

    def input_signature(self):
        """input_signature(self) -> gr_io_signature_sptr"""
        return _gnuradio_core_filter.gr_freq_xlating_fir_filter_ccc_sptr_input_signature(self)

    def output_signature(self):
        """output_signature(self) -> gr_io_signature_sptr"""
        return _gnuradio_core_filter.gr_freq_xlating_fir_filter_ccc_sptr_output_signature(self)

    def unique_id(self):
        """unique_id(self) -> long"""
        return _gnuradio_core_filter.gr_freq_xlating_fir_filter_ccc_sptr_unique_id(self)

    def to_basic_block(self):
        """to_basic_block(self) -> gr_basic_block_sptr"""
        return _gnuradio_core_filter.gr_freq_xlating_fir_filter_ccc_sptr_to_basic_block(self)

    def check_topology(self, *args, **kwargs):
        """check_topology(self, int ninputs, int noutputs) -> bool"""
        return _gnuradio_core_filter.gr_freq_xlating_fir_filter_ccc_sptr_check_topology(self, *args, **kwargs)

gr_freq_xlating_fir_filter_ccc_sptr_swigregister = _gnuradio_core_filter.gr_freq_xlating_fir_filter_ccc_sptr_swigregister
gr_freq_xlating_fir_filter_ccc_sptr_swigregister(gr_freq_xlating_fir_filter_ccc_sptr)

gr_freq_xlating_fir_filter_ccc_sptr.__repr__ = lambda self: "<gr_block %s (%d)>" % (self.name(), self.unique_id ())


def freq_xlating_fir_filter_ccc(*args, **kwargs):
  """
    freq_xlating_fir_filter_ccc(int decimation, std::vector<(gr_complex,std::allocator<(gr_complex)>)> taps, 
        double center_freq, 
        double sampling_freq) -> gr_freq_xlating_fir_filter_ccc_sptr

    FIR filter combined with frequency translation with gr_complex input, gr_complex output and gr_complex taps

    This class efficiently combines a frequency translation (typically "down conversion") with a FIR filter (typically low-pass) and decimation. It is ideally suited for a "channel selection filter" and can be efficiently used to select and decimate a narrow band signal out of wide bandwidth input.

    Uses a single input array to produce a single output array. Additional inputs and/or outputs are ignored.

    Construct a FIR filter with the given taps and a composite frequency translation that shifts center_freq down to zero Hz. The frequency translation logically comes before the filtering operation.
    """
  return _gnuradio_core_filter.freq_xlating_fir_filter_ccc(*args, **kwargs)
class gr_freq_xlating_fir_filter_ccf_sptr(object):
    """Proxy of C++ boost::shared_ptr<(gr_freq_xlating_fir_filter_ccf)> class"""
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(self) -> gr_freq_xlating_fir_filter_ccf_sptr
        __init__(self,  p) -> gr_freq_xlating_fir_filter_ccf_sptr
        """
        this = _gnuradio_core_filter.new_gr_freq_xlating_fir_filter_ccf_sptr(*args)
        try: self.this.append(this)
        except: self.this = this
    def __deref__(self):
        """__deref__(self)"""
        return _gnuradio_core_filter.gr_freq_xlating_fir_filter_ccf_sptr___deref__(self)

    __swig_destroy__ = _gnuradio_core_filter.delete_gr_freq_xlating_fir_filter_ccf_sptr
    __del__ = lambda self : None;
    def set_center_freq(self, *args, **kwargs):
        """set_center_freq(self, double center_freq)"""
        return _gnuradio_core_filter.gr_freq_xlating_fir_filter_ccf_sptr_set_center_freq(self, *args, **kwargs)

    def set_taps(self, *args, **kwargs):
        """set_taps(self, __dummy_4__ taps)"""
        return _gnuradio_core_filter.gr_freq_xlating_fir_filter_ccf_sptr_set_taps(self, *args, **kwargs)

    def history(self):
        """history(self) -> unsigned int"""
        return _gnuradio_core_filter.gr_freq_xlating_fir_filter_ccf_sptr_history(self)

    def output_multiple(self):
        """output_multiple(self) -> int"""
        return _gnuradio_core_filter.gr_freq_xlating_fir_filter_ccf_sptr_output_multiple(self)

    def relative_rate(self):
        """relative_rate(self) -> double"""
        return _gnuradio_core_filter.gr_freq_xlating_fir_filter_ccf_sptr_relative_rate(self)

    def start(self):
        """start(self) -> bool"""
        return _gnuradio_core_filter.gr_freq_xlating_fir_filter_ccf_sptr_start(self)

    def stop(self):
        """stop(self) -> bool"""
        return _gnuradio_core_filter.gr_freq_xlating_fir_filter_ccf_sptr_stop(self)

    def nitems_read(self, *args, **kwargs):
        """nitems_read(self, unsigned int which_input) -> uint64_t"""
        return _gnuradio_core_filter.gr_freq_xlating_fir_filter_ccf_sptr_nitems_read(self, *args, **kwargs)

    def nitems_written(self, *args, **kwargs):
        """nitems_written(self, unsigned int which_output) -> uint64_t"""
        return _gnuradio_core_filter.gr_freq_xlating_fir_filter_ccf_sptr_nitems_written(self, *args, **kwargs)

    def detail(self):
        """detail(self) -> gr_block_detail_sptr"""
        return _gnuradio_core_filter.gr_freq_xlating_fir_filter_ccf_sptr_detail(self)

    def set_detail(self, *args, **kwargs):
        """set_detail(self, gr_block_detail_sptr detail)"""
        return _gnuradio_core_filter.gr_freq_xlating_fir_filter_ccf_sptr_set_detail(self, *args, **kwargs)

    def name(self):
        """name(self) -> string"""
        return _gnuradio_core_filter.gr_freq_xlating_fir_filter_ccf_sptr_name(self)

    def input_signature(self):
        """input_signature(self) -> gr_io_signature_sptr"""
        return _gnuradio_core_filter.gr_freq_xlating_fir_filter_ccf_sptr_input_signature(self)

    def output_signature(self):
        """output_signature(self) -> gr_io_signature_sptr"""
        return _gnuradio_core_filter.gr_freq_xlating_fir_filter_ccf_sptr_output_signature(self)

    def unique_id(self):
        """unique_id(self) -> long"""
        return _gnuradio_core_filter.gr_freq_xlating_fir_filter_ccf_sptr_unique_id(self)

    def to_basic_block(self):
        """to_basic_block(self) -> gr_basic_block_sptr"""
        return _gnuradio_core_filter.gr_freq_xlating_fir_filter_ccf_sptr_to_basic_block(self)

    def check_topology(self, *args, **kwargs):
        """check_topology(self, int ninputs, int noutputs) -> bool"""
        return _gnuradio_core_filter.gr_freq_xlating_fir_filter_ccf_sptr_check_topology(self, *args, **kwargs)

gr_freq_xlating_fir_filter_ccf_sptr_swigregister = _gnuradio_core_filter.gr_freq_xlating_fir_filter_ccf_sptr_swigregister
gr_freq_xlating_fir_filter_ccf_sptr_swigregister(gr_freq_xlating_fir_filter_ccf_sptr)

gr_freq_xlating_fir_filter_ccf_sptr.__repr__ = lambda self: "<gr_block %s (%d)>" % (self.name(), self.unique_id ())


def freq_xlating_fir_filter_ccf(*args, **kwargs):
  """
    freq_xlating_fir_filter_ccf(int decimation, __dummy_4__ taps, double center_freq, 
        double sampling_freq) -> gr_freq_xlating_fir_filter_ccf_sptr

    FIR filter combined with frequency translation with gr_complex input, gr_complex output and float taps

    This class efficiently combines a frequency translation (typically "down conversion") with a FIR filter (typically low-pass) and decimation. It is ideally suited for a "channel selection filter" and can be efficiently used to select and decimate a narrow band signal out of wide bandwidth input.

    Uses a single input array to produce a single output array. Additional inputs and/or outputs are ignored.

    Construct a FIR filter with the given taps and a composite frequency translation that shifts center_freq down to zero Hz. The frequency translation logically comes before the filtering operation.
    """
  return _gnuradio_core_filter.freq_xlating_fir_filter_ccf(*args, **kwargs)
class gr_freq_xlating_fir_filter_fcc_sptr(object):
    """Proxy of C++ boost::shared_ptr<(gr_freq_xlating_fir_filter_fcc)> class"""
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(self) -> gr_freq_xlating_fir_filter_fcc_sptr
        __init__(self,  p) -> gr_freq_xlating_fir_filter_fcc_sptr
        """
        this = _gnuradio_core_filter.new_gr_freq_xlating_fir_filter_fcc_sptr(*args)
        try: self.this.append(this)
        except: self.this = this
    def __deref__(self):
        """__deref__(self)"""
        return _gnuradio_core_filter.gr_freq_xlating_fir_filter_fcc_sptr___deref__(self)

    __swig_destroy__ = _gnuradio_core_filter.delete_gr_freq_xlating_fir_filter_fcc_sptr
    __del__ = lambda self : None;
    def set_center_freq(self, *args, **kwargs):
        """set_center_freq(self, double center_freq)"""
        return _gnuradio_core_filter.gr_freq_xlating_fir_filter_fcc_sptr_set_center_freq(self, *args, **kwargs)

    def set_taps(self, *args, **kwargs):
        """set_taps(self, std::vector<(gr_complex,std::allocator<(gr_complex)>)> taps)"""
        return _gnuradio_core_filter.gr_freq_xlating_fir_filter_fcc_sptr_set_taps(self, *args, **kwargs)

    def history(self):
        """history(self) -> unsigned int"""
        return _gnuradio_core_filter.gr_freq_xlating_fir_filter_fcc_sptr_history(self)

    def output_multiple(self):
        """output_multiple(self) -> int"""
        return _gnuradio_core_filter.gr_freq_xlating_fir_filter_fcc_sptr_output_multiple(self)

    def relative_rate(self):
        """relative_rate(self) -> double"""
        return _gnuradio_core_filter.gr_freq_xlating_fir_filter_fcc_sptr_relative_rate(self)

    def start(self):
        """start(self) -> bool"""
        return _gnuradio_core_filter.gr_freq_xlating_fir_filter_fcc_sptr_start(self)

    def stop(self):
        """stop(self) -> bool"""
        return _gnuradio_core_filter.gr_freq_xlating_fir_filter_fcc_sptr_stop(self)

    def nitems_read(self, *args, **kwargs):
        """nitems_read(self, unsigned int which_input) -> uint64_t"""
        return _gnuradio_core_filter.gr_freq_xlating_fir_filter_fcc_sptr_nitems_read(self, *args, **kwargs)

    def nitems_written(self, *args, **kwargs):
        """nitems_written(self, unsigned int which_output) -> uint64_t"""
        return _gnuradio_core_filter.gr_freq_xlating_fir_filter_fcc_sptr_nitems_written(self, *args, **kwargs)

    def detail(self):
        """detail(self) -> gr_block_detail_sptr"""
        return _gnuradio_core_filter.gr_freq_xlating_fir_filter_fcc_sptr_detail(self)

    def set_detail(self, *args, **kwargs):
        """set_detail(self, gr_block_detail_sptr detail)"""
        return _gnuradio_core_filter.gr_freq_xlating_fir_filter_fcc_sptr_set_detail(self, *args, **kwargs)

    def name(self):
        """name(self) -> string"""
        return _gnuradio_core_filter.gr_freq_xlating_fir_filter_fcc_sptr_name(self)

    def input_signature(self):
        """input_signature(self) -> gr_io_signature_sptr"""
        return _gnuradio_core_filter.gr_freq_xlating_fir_filter_fcc_sptr_input_signature(self)

    def output_signature(self):
        """output_signature(self) -> gr_io_signature_sptr"""
        return _gnuradio_core_filter.gr_freq_xlating_fir_filter_fcc_sptr_output_signature(self)

    def unique_id(self):
        """unique_id(self) -> long"""
        return _gnuradio_core_filter.gr_freq_xlating_fir_filter_fcc_sptr_unique_id(self)

    def to_basic_block(self):
        """to_basic_block(self) -> gr_basic_block_sptr"""
        return _gnuradio_core_filter.gr_freq_xlating_fir_filter_fcc_sptr_to_basic_block(self)

    def check_topology(self, *args, **kwargs):
        """check_topology(self, int ninputs, int noutputs) -> bool"""
        return _gnuradio_core_filter.gr_freq_xlating_fir_filter_fcc_sptr_check_topology(self, *args, **kwargs)

gr_freq_xlating_fir_filter_fcc_sptr_swigregister = _gnuradio_core_filter.gr_freq_xlating_fir_filter_fcc_sptr_swigregister
gr_freq_xlating_fir_filter_fcc_sptr_swigregister(gr_freq_xlating_fir_filter_fcc_sptr)

gr_freq_xlating_fir_filter_fcc_sptr.__repr__ = lambda self: "<gr_block %s (%d)>" % (self.name(), self.unique_id ())


def freq_xlating_fir_filter_fcc(*args, **kwargs):
  """
    freq_xlating_fir_filter_fcc(int decimation, std::vector<(gr_complex,std::allocator<(gr_complex)>)> taps, 
        double center_freq, 
        double sampling_freq) -> gr_freq_xlating_fir_filter_fcc_sptr

    FIR filter combined with frequency translation with float input, gr_complex output and gr_complex taps

    This class efficiently combines a frequency translation (typically "down conversion") with a FIR filter (typically low-pass) and decimation. It is ideally suited for a "channel selection filter" and can be efficiently used to select and decimate a narrow band signal out of wide bandwidth input.

    Uses a single input array to produce a single output array. Additional inputs and/or outputs are ignored.

    Construct a FIR filter with the given taps and a composite frequency translation that shifts center_freq down to zero Hz. The frequency translation logically comes before the filtering operation.
    """
  return _gnuradio_core_filter.freq_xlating_fir_filter_fcc(*args, **kwargs)
class gr_freq_xlating_fir_filter_fcf_sptr(object):
    """Proxy of C++ boost::shared_ptr<(gr_freq_xlating_fir_filter_fcf)> class"""
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(self) -> gr_freq_xlating_fir_filter_fcf_sptr
        __init__(self,  p) -> gr_freq_xlating_fir_filter_fcf_sptr
        """
        this = _gnuradio_core_filter.new_gr_freq_xlating_fir_filter_fcf_sptr(*args)
        try: self.this.append(this)
        except: self.this = this
    def __deref__(self):
        """__deref__(self)"""
        return _gnuradio_core_filter.gr_freq_xlating_fir_filter_fcf_sptr___deref__(self)

    __swig_destroy__ = _gnuradio_core_filter.delete_gr_freq_xlating_fir_filter_fcf_sptr
    __del__ = lambda self : None;
    def set_center_freq(self, *args, **kwargs):
        """set_center_freq(self, double center_freq)"""
        return _gnuradio_core_filter.gr_freq_xlating_fir_filter_fcf_sptr_set_center_freq(self, *args, **kwargs)

    def set_taps(self, *args, **kwargs):
        """set_taps(self, __dummy_4__ taps)"""
        return _gnuradio_core_filter.gr_freq_xlating_fir_filter_fcf_sptr_set_taps(self, *args, **kwargs)

    def history(self):
        """history(self) -> unsigned int"""
        return _gnuradio_core_filter.gr_freq_xlating_fir_filter_fcf_sptr_history(self)

    def output_multiple(self):
        """output_multiple(self) -> int"""
        return _gnuradio_core_filter.gr_freq_xlating_fir_filter_fcf_sptr_output_multiple(self)

    def relative_rate(self):
        """relative_rate(self) -> double"""
        return _gnuradio_core_filter.gr_freq_xlating_fir_filter_fcf_sptr_relative_rate(self)

    def start(self):
        """start(self) -> bool"""
        return _gnuradio_core_filter.gr_freq_xlating_fir_filter_fcf_sptr_start(self)

    def stop(self):
        """stop(self) -> bool"""
        return _gnuradio_core_filter.gr_freq_xlating_fir_filter_fcf_sptr_stop(self)

    def nitems_read(self, *args, **kwargs):
        """nitems_read(self, unsigned int which_input) -> uint64_t"""
        return _gnuradio_core_filter.gr_freq_xlating_fir_filter_fcf_sptr_nitems_read(self, *args, **kwargs)

    def nitems_written(self, *args, **kwargs):
        """nitems_written(self, unsigned int which_output) -> uint64_t"""
        return _gnuradio_core_filter.gr_freq_xlating_fir_filter_fcf_sptr_nitems_written(self, *args, **kwargs)

    def detail(self):
        """detail(self) -> gr_block_detail_sptr"""
        return _gnuradio_core_filter.gr_freq_xlating_fir_filter_fcf_sptr_detail(self)

    def set_detail(self, *args, **kwargs):
        """set_detail(self, gr_block_detail_sptr detail)"""
        return _gnuradio_core_filter.gr_freq_xlating_fir_filter_fcf_sptr_set_detail(self, *args, **kwargs)

    def name(self):
        """name(self) -> string"""
        return _gnuradio_core_filter.gr_freq_xlating_fir_filter_fcf_sptr_name(self)

    def input_signature(self):
        """input_signature(self) -> gr_io_signature_sptr"""
        return _gnuradio_core_filter.gr_freq_xlating_fir_filter_fcf_sptr_input_signature(self)

    def output_signature(self):
        """output_signature(self) -> gr_io_signature_sptr"""
        return _gnuradio_core_filter.gr_freq_xlating_fir_filter_fcf_sptr_output_signature(self)

    def unique_id(self):
        """unique_id(self) -> long"""
        return _gnuradio_core_filter.gr_freq_xlating_fir_filter_fcf_sptr_unique_id(self)

    def to_basic_block(self):
        """to_basic_block(self) -> gr_basic_block_sptr"""
        return _gnuradio_core_filter.gr_freq_xlating_fir_filter_fcf_sptr_to_basic_block(self)

    def check_topology(self, *args, **kwargs):
        """check_topology(self, int ninputs, int noutputs) -> bool"""
        return _gnuradio_core_filter.gr_freq_xlating_fir_filter_fcf_sptr_check_topology(self, *args, **kwargs)

gr_freq_xlating_fir_filter_fcf_sptr_swigregister = _gnuradio_core_filter.gr_freq_xlating_fir_filter_fcf_sptr_swigregister
gr_freq_xlating_fir_filter_fcf_sptr_swigregister(gr_freq_xlating_fir_filter_fcf_sptr)

gr_freq_xlating_fir_filter_fcf_sptr.__repr__ = lambda self: "<gr_block %s (%d)>" % (self.name(), self.unique_id ())


def freq_xlating_fir_filter_fcf(*args, **kwargs):
  """
    freq_xlating_fir_filter_fcf(int decimation, __dummy_4__ taps, double center_freq, 
        double sampling_freq) -> gr_freq_xlating_fir_filter_fcf_sptr

    FIR filter combined with frequency translation with float input, gr_complex output and float taps

    This class efficiently combines a frequency translation (typically "down conversion") with a FIR filter (typically low-pass) and decimation. It is ideally suited for a "channel selection filter" and can be efficiently used to select and decimate a narrow band signal out of wide bandwidth input.

    Uses a single input array to produce a single output array. Additional inputs and/or outputs are ignored.

    Construct a FIR filter with the given taps and a composite frequency translation that shifts center_freq down to zero Hz. The frequency translation logically comes before the filtering operation.
    """
  return _gnuradio_core_filter.freq_xlating_fir_filter_fcf(*args, **kwargs)
class gr_freq_xlating_fir_filter_scc_sptr(object):
    """Proxy of C++ boost::shared_ptr<(gr_freq_xlating_fir_filter_scc)> class"""
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(self) -> gr_freq_xlating_fir_filter_scc_sptr
        __init__(self,  p) -> gr_freq_xlating_fir_filter_scc_sptr
        """
        this = _gnuradio_core_filter.new_gr_freq_xlating_fir_filter_scc_sptr(*args)
        try: self.this.append(this)
        except: self.this = this
    def __deref__(self):
        """__deref__(self)"""
        return _gnuradio_core_filter.gr_freq_xlating_fir_filter_scc_sptr___deref__(self)

    __swig_destroy__ = _gnuradio_core_filter.delete_gr_freq_xlating_fir_filter_scc_sptr
    __del__ = lambda self : None;
    def set_center_freq(self, *args, **kwargs):
        """set_center_freq(self, double center_freq)"""
        return _gnuradio_core_filter.gr_freq_xlating_fir_filter_scc_sptr_set_center_freq(self, *args, **kwargs)

    def set_taps(self, *args, **kwargs):
        """set_taps(self, std::vector<(gr_complex,std::allocator<(gr_complex)>)> taps)"""
        return _gnuradio_core_filter.gr_freq_xlating_fir_filter_scc_sptr_set_taps(self, *args, **kwargs)

    def history(self):
        """history(self) -> unsigned int"""
        return _gnuradio_core_filter.gr_freq_xlating_fir_filter_scc_sptr_history(self)

    def output_multiple(self):
        """output_multiple(self) -> int"""
        return _gnuradio_core_filter.gr_freq_xlating_fir_filter_scc_sptr_output_multiple(self)

    def relative_rate(self):
        """relative_rate(self) -> double"""
        return _gnuradio_core_filter.gr_freq_xlating_fir_filter_scc_sptr_relative_rate(self)

    def start(self):
        """start(self) -> bool"""
        return _gnuradio_core_filter.gr_freq_xlating_fir_filter_scc_sptr_start(self)

    def stop(self):
        """stop(self) -> bool"""
        return _gnuradio_core_filter.gr_freq_xlating_fir_filter_scc_sptr_stop(self)

    def nitems_read(self, *args, **kwargs):
        """nitems_read(self, unsigned int which_input) -> uint64_t"""
        return _gnuradio_core_filter.gr_freq_xlating_fir_filter_scc_sptr_nitems_read(self, *args, **kwargs)

    def nitems_written(self, *args, **kwargs):
        """nitems_written(self, unsigned int which_output) -> uint64_t"""
        return _gnuradio_core_filter.gr_freq_xlating_fir_filter_scc_sptr_nitems_written(self, *args, **kwargs)

    def detail(self):
        """detail(self) -> gr_block_detail_sptr"""
        return _gnuradio_core_filter.gr_freq_xlating_fir_filter_scc_sptr_detail(self)

    def set_detail(self, *args, **kwargs):
        """set_detail(self, gr_block_detail_sptr detail)"""
        return _gnuradio_core_filter.gr_freq_xlating_fir_filter_scc_sptr_set_detail(self, *args, **kwargs)

    def name(self):
        """name(self) -> string"""
        return _gnuradio_core_filter.gr_freq_xlating_fir_filter_scc_sptr_name(self)

    def input_signature(self):
        """input_signature(self) -> gr_io_signature_sptr"""
        return _gnuradio_core_filter.gr_freq_xlating_fir_filter_scc_sptr_input_signature(self)

    def output_signature(self):
        """output_signature(self) -> gr_io_signature_sptr"""
        return _gnuradio_core_filter.gr_freq_xlating_fir_filter_scc_sptr_output_signature(self)

    def unique_id(self):
        """unique_id(self) -> long"""
        return _gnuradio_core_filter.gr_freq_xlating_fir_filter_scc_sptr_unique_id(self)

    def to_basic_block(self):
        """to_basic_block(self) -> gr_basic_block_sptr"""
        return _gnuradio_core_filter.gr_freq_xlating_fir_filter_scc_sptr_to_basic_block(self)

    def check_topology(self, *args, **kwargs):
        """check_topology(self, int ninputs, int noutputs) -> bool"""
        return _gnuradio_core_filter.gr_freq_xlating_fir_filter_scc_sptr_check_topology(self, *args, **kwargs)

gr_freq_xlating_fir_filter_scc_sptr_swigregister = _gnuradio_core_filter.gr_freq_xlating_fir_filter_scc_sptr_swigregister
gr_freq_xlating_fir_filter_scc_sptr_swigregister(gr_freq_xlating_fir_filter_scc_sptr)

gr_freq_xlating_fir_filter_scc_sptr.__repr__ = lambda self: "<gr_block %s (%d)>" % (self.name(), self.unique_id ())


def freq_xlating_fir_filter_scc(*args, **kwargs):
  """
    freq_xlating_fir_filter_scc(int decimation, std::vector<(gr_complex,std::allocator<(gr_complex)>)> taps, 
        double center_freq, 
        double sampling_freq) -> gr_freq_xlating_fir_filter_scc_sptr

    FIR filter combined with frequency translation with short input, gr_complex output and gr_complex taps

    This class efficiently combines a frequency translation (typically "down conversion") with a FIR filter (typically low-pass) and decimation. It is ideally suited for a "channel selection filter" and can be efficiently used to select and decimate a narrow band signal out of wide bandwidth input.

    Uses a single input array to produce a single output array. Additional inputs and/or outputs are ignored.

    Construct a FIR filter with the given taps and a composite frequency translation that shifts center_freq down to zero Hz. The frequency translation logically comes before the filtering operation.
    """
  return _gnuradio_core_filter.freq_xlating_fir_filter_scc(*args, **kwargs)
class gr_freq_xlating_fir_filter_scf_sptr(object):
    """Proxy of C++ boost::shared_ptr<(gr_freq_xlating_fir_filter_scf)> class"""
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(self) -> gr_freq_xlating_fir_filter_scf_sptr
        __init__(self,  p) -> gr_freq_xlating_fir_filter_scf_sptr
        """
        this = _gnuradio_core_filter.new_gr_freq_xlating_fir_filter_scf_sptr(*args)
        try: self.this.append(this)
        except: self.this = this
    def __deref__(self):
        """__deref__(self)"""
        return _gnuradio_core_filter.gr_freq_xlating_fir_filter_scf_sptr___deref__(self)

    __swig_destroy__ = _gnuradio_core_filter.delete_gr_freq_xlating_fir_filter_scf_sptr
    __del__ = lambda self : None;
    def set_center_freq(self, *args, **kwargs):
        """set_center_freq(self, double center_freq)"""
        return _gnuradio_core_filter.gr_freq_xlating_fir_filter_scf_sptr_set_center_freq(self, *args, **kwargs)

    def set_taps(self, *args, **kwargs):
        """set_taps(self, __dummy_4__ taps)"""
        return _gnuradio_core_filter.gr_freq_xlating_fir_filter_scf_sptr_set_taps(self, *args, **kwargs)

    def history(self):
        """history(self) -> unsigned int"""
        return _gnuradio_core_filter.gr_freq_xlating_fir_filter_scf_sptr_history(self)

    def output_multiple(self):
        """output_multiple(self) -> int"""
        return _gnuradio_core_filter.gr_freq_xlating_fir_filter_scf_sptr_output_multiple(self)

    def relative_rate(self):
        """relative_rate(self) -> double"""
        return _gnuradio_core_filter.gr_freq_xlating_fir_filter_scf_sptr_relative_rate(self)

    def start(self):
        """start(self) -> bool"""
        return _gnuradio_core_filter.gr_freq_xlating_fir_filter_scf_sptr_start(self)

    def stop(self):
        """stop(self) -> bool"""
        return _gnuradio_core_filter.gr_freq_xlating_fir_filter_scf_sptr_stop(self)

    def nitems_read(self, *args, **kwargs):
        """nitems_read(self, unsigned int which_input) -> uint64_t"""
        return _gnuradio_core_filter.gr_freq_xlating_fir_filter_scf_sptr_nitems_read(self, *args, **kwargs)

    def nitems_written(self, *args, **kwargs):
        """nitems_written(self, unsigned int which_output) -> uint64_t"""
        return _gnuradio_core_filter.gr_freq_xlating_fir_filter_scf_sptr_nitems_written(self, *args, **kwargs)

    def detail(self):
        """detail(self) -> gr_block_detail_sptr"""
        return _gnuradio_core_filter.gr_freq_xlating_fir_filter_scf_sptr_detail(self)

    def set_detail(self, *args, **kwargs):
        """set_detail(self, gr_block_detail_sptr detail)"""
        return _gnuradio_core_filter.gr_freq_xlating_fir_filter_scf_sptr_set_detail(self, *args, **kwargs)

    def name(self):
        """name(self) -> string"""
        return _gnuradio_core_filter.gr_freq_xlating_fir_filter_scf_sptr_name(self)

    def input_signature(self):
        """input_signature(self) -> gr_io_signature_sptr"""
        return _gnuradio_core_filter.gr_freq_xlating_fir_filter_scf_sptr_input_signature(self)

    def output_signature(self):
        """output_signature(self) -> gr_io_signature_sptr"""
        return _gnuradio_core_filter.gr_freq_xlating_fir_filter_scf_sptr_output_signature(self)

    def unique_id(self):
        """unique_id(self) -> long"""
        return _gnuradio_core_filter.gr_freq_xlating_fir_filter_scf_sptr_unique_id(self)

    def to_basic_block(self):
        """to_basic_block(self) -> gr_basic_block_sptr"""
        return _gnuradio_core_filter.gr_freq_xlating_fir_filter_scf_sptr_to_basic_block(self)

    def check_topology(self, *args, **kwargs):
        """check_topology(self, int ninputs, int noutputs) -> bool"""
        return _gnuradio_core_filter.gr_freq_xlating_fir_filter_scf_sptr_check_topology(self, *args, **kwargs)

gr_freq_xlating_fir_filter_scf_sptr_swigregister = _gnuradio_core_filter.gr_freq_xlating_fir_filter_scf_sptr_swigregister
gr_freq_xlating_fir_filter_scf_sptr_swigregister(gr_freq_xlating_fir_filter_scf_sptr)

gr_freq_xlating_fir_filter_scf_sptr.__repr__ = lambda self: "<gr_block %s (%d)>" % (self.name(), self.unique_id ())


def freq_xlating_fir_filter_scf(*args, **kwargs):
  """
    freq_xlating_fir_filter_scf(int decimation, __dummy_4__ taps, double center_freq, 
        double sampling_freq) -> gr_freq_xlating_fir_filter_scf_sptr

    FIR filter combined with frequency translation with short input, gr_complex output and float taps

    This class efficiently combines a frequency translation (typically "down conversion") with a FIR filter (typically low-pass) and decimation. It is ideally suited for a "channel selection filter" and can be efficiently used to select and decimate a narrow band signal out of wide bandwidth input.

    Uses a single input array to produce a single output array. Additional inputs and/or outputs are ignored.

    Construct a FIR filter with the given taps and a composite frequency translation that shifts center_freq down to zero Hz. The frequency translation logically comes before the filtering operation.
    """
  return _gnuradio_core_filter.freq_xlating_fir_filter_scf(*args, **kwargs)
class gr_interp_fir_filter_ccc_sptr(object):
    """Proxy of C++ boost::shared_ptr<(gr_interp_fir_filter_ccc)> class"""
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(self) -> gr_interp_fir_filter_ccc_sptr
        __init__(self,  p) -> gr_interp_fir_filter_ccc_sptr
        """
        this = _gnuradio_core_filter.new_gr_interp_fir_filter_ccc_sptr(*args)
        try: self.this.append(this)
        except: self.this = this
    def __deref__(self):
        """__deref__(self)"""
        return _gnuradio_core_filter.gr_interp_fir_filter_ccc_sptr___deref__(self)

    __swig_destroy__ = _gnuradio_core_filter.delete_gr_interp_fir_filter_ccc_sptr
    __del__ = lambda self : None;
    def set_taps(self, *args, **kwargs):
        """set_taps(self, std::vector<(gr_complex,std::allocator<(gr_complex)>)> taps)"""
        return _gnuradio_core_filter.gr_interp_fir_filter_ccc_sptr_set_taps(self, *args, **kwargs)

    def history(self):
        """history(self) -> unsigned int"""
        return _gnuradio_core_filter.gr_interp_fir_filter_ccc_sptr_history(self)

    def output_multiple(self):
        """output_multiple(self) -> int"""
        return _gnuradio_core_filter.gr_interp_fir_filter_ccc_sptr_output_multiple(self)

    def relative_rate(self):
        """relative_rate(self) -> double"""
        return _gnuradio_core_filter.gr_interp_fir_filter_ccc_sptr_relative_rate(self)

    def start(self):
        """start(self) -> bool"""
        return _gnuradio_core_filter.gr_interp_fir_filter_ccc_sptr_start(self)

    def stop(self):
        """stop(self) -> bool"""
        return _gnuradio_core_filter.gr_interp_fir_filter_ccc_sptr_stop(self)

    def nitems_read(self, *args, **kwargs):
        """nitems_read(self, unsigned int which_input) -> uint64_t"""
        return _gnuradio_core_filter.gr_interp_fir_filter_ccc_sptr_nitems_read(self, *args, **kwargs)

    def nitems_written(self, *args, **kwargs):
        """nitems_written(self, unsigned int which_output) -> uint64_t"""
        return _gnuradio_core_filter.gr_interp_fir_filter_ccc_sptr_nitems_written(self, *args, **kwargs)

    def detail(self):
        """detail(self) -> gr_block_detail_sptr"""
        return _gnuradio_core_filter.gr_interp_fir_filter_ccc_sptr_detail(self)

    def set_detail(self, *args, **kwargs):
        """set_detail(self, gr_block_detail_sptr detail)"""
        return _gnuradio_core_filter.gr_interp_fir_filter_ccc_sptr_set_detail(self, *args, **kwargs)

    def name(self):
        """name(self) -> string"""
        return _gnuradio_core_filter.gr_interp_fir_filter_ccc_sptr_name(self)

    def input_signature(self):
        """input_signature(self) -> gr_io_signature_sptr"""
        return _gnuradio_core_filter.gr_interp_fir_filter_ccc_sptr_input_signature(self)

    def output_signature(self):
        """output_signature(self) -> gr_io_signature_sptr"""
        return _gnuradio_core_filter.gr_interp_fir_filter_ccc_sptr_output_signature(self)

    def unique_id(self):
        """unique_id(self) -> long"""
        return _gnuradio_core_filter.gr_interp_fir_filter_ccc_sptr_unique_id(self)

    def to_basic_block(self):
        """to_basic_block(self) -> gr_basic_block_sptr"""
        return _gnuradio_core_filter.gr_interp_fir_filter_ccc_sptr_to_basic_block(self)

    def check_topology(self, *args, **kwargs):
        """check_topology(self, int ninputs, int noutputs) -> bool"""
        return _gnuradio_core_filter.gr_interp_fir_filter_ccc_sptr_check_topology(self, *args, **kwargs)

gr_interp_fir_filter_ccc_sptr_swigregister = _gnuradio_core_filter.gr_interp_fir_filter_ccc_sptr_swigregister
gr_interp_fir_filter_ccc_sptr_swigregister(gr_interp_fir_filter_ccc_sptr)

gr_interp_fir_filter_ccc_sptr.__repr__ = lambda self: "<gr_block %s (%d)>" % (self.name(), self.unique_id ())


def interp_fir_filter_ccc(*args, **kwargs):
  """
    interp_fir_filter_ccc(int interpolation, std::vector<(gr_complex,std::allocator<(gr_complex)>)> taps) -> gr_interp_fir_filter_ccc_sptr

    Interpolating FIR filter with gr_complex input, gr_complex output and gr_complex taps.
    """
  return _gnuradio_core_filter.interp_fir_filter_ccc(*args, **kwargs)
class gr_interp_fir_filter_ccf_sptr(object):
    """Proxy of C++ boost::shared_ptr<(gr_interp_fir_filter_ccf)> class"""
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(self) -> gr_interp_fir_filter_ccf_sptr
        __init__(self,  p) -> gr_interp_fir_filter_ccf_sptr
        """
        this = _gnuradio_core_filter.new_gr_interp_fir_filter_ccf_sptr(*args)
        try: self.this.append(this)
        except: self.this = this
    def __deref__(self):
        """__deref__(self)"""
        return _gnuradio_core_filter.gr_interp_fir_filter_ccf_sptr___deref__(self)

    __swig_destroy__ = _gnuradio_core_filter.delete_gr_interp_fir_filter_ccf_sptr
    __del__ = lambda self : None;
    def set_taps(self, *args, **kwargs):
        """set_taps(self, __dummy_4__ taps)"""
        return _gnuradio_core_filter.gr_interp_fir_filter_ccf_sptr_set_taps(self, *args, **kwargs)

    def history(self):
        """history(self) -> unsigned int"""
        return _gnuradio_core_filter.gr_interp_fir_filter_ccf_sptr_history(self)

    def output_multiple(self):
        """output_multiple(self) -> int"""
        return _gnuradio_core_filter.gr_interp_fir_filter_ccf_sptr_output_multiple(self)

    def relative_rate(self):
        """relative_rate(self) -> double"""
        return _gnuradio_core_filter.gr_interp_fir_filter_ccf_sptr_relative_rate(self)

    def start(self):
        """start(self) -> bool"""
        return _gnuradio_core_filter.gr_interp_fir_filter_ccf_sptr_start(self)

    def stop(self):
        """stop(self) -> bool"""
        return _gnuradio_core_filter.gr_interp_fir_filter_ccf_sptr_stop(self)

    def nitems_read(self, *args, **kwargs):
        """nitems_read(self, unsigned int which_input) -> uint64_t"""
        return _gnuradio_core_filter.gr_interp_fir_filter_ccf_sptr_nitems_read(self, *args, **kwargs)

    def nitems_written(self, *args, **kwargs):
        """nitems_written(self, unsigned int which_output) -> uint64_t"""
        return _gnuradio_core_filter.gr_interp_fir_filter_ccf_sptr_nitems_written(self, *args, **kwargs)

    def detail(self):
        """detail(self) -> gr_block_detail_sptr"""
        return _gnuradio_core_filter.gr_interp_fir_filter_ccf_sptr_detail(self)

    def set_detail(self, *args, **kwargs):
        """set_detail(self, gr_block_detail_sptr detail)"""
        return _gnuradio_core_filter.gr_interp_fir_filter_ccf_sptr_set_detail(self, *args, **kwargs)

    def name(self):
        """name(self) -> string"""
        return _gnuradio_core_filter.gr_interp_fir_filter_ccf_sptr_name(self)

    def input_signature(self):
        """input_signature(self) -> gr_io_signature_sptr"""
        return _gnuradio_core_filter.gr_interp_fir_filter_ccf_sptr_input_signature(self)

    def output_signature(self):
        """output_signature(self) -> gr_io_signature_sptr"""
        return _gnuradio_core_filter.gr_interp_fir_filter_ccf_sptr_output_signature(self)

    def unique_id(self):
        """unique_id(self) -> long"""
        return _gnuradio_core_filter.gr_interp_fir_filter_ccf_sptr_unique_id(self)

    def to_basic_block(self):
        """to_basic_block(self) -> gr_basic_block_sptr"""
        return _gnuradio_core_filter.gr_interp_fir_filter_ccf_sptr_to_basic_block(self)

    def check_topology(self, *args, **kwargs):
        """check_topology(self, int ninputs, int noutputs) -> bool"""
        return _gnuradio_core_filter.gr_interp_fir_filter_ccf_sptr_check_topology(self, *args, **kwargs)

gr_interp_fir_filter_ccf_sptr_swigregister = _gnuradio_core_filter.gr_interp_fir_filter_ccf_sptr_swigregister
gr_interp_fir_filter_ccf_sptr_swigregister(gr_interp_fir_filter_ccf_sptr)

gr_interp_fir_filter_ccf_sptr.__repr__ = lambda self: "<gr_block %s (%d)>" % (self.name(), self.unique_id ())


def interp_fir_filter_ccf(*args, **kwargs):
  """
    interp_fir_filter_ccf(int interpolation, __dummy_4__ taps) -> gr_interp_fir_filter_ccf_sptr

    Interpolating FIR filter with gr_complex input, gr_complex output and float taps.
    """
  return _gnuradio_core_filter.interp_fir_filter_ccf(*args, **kwargs)
class gr_interp_fir_filter_fcc_sptr(object):
    """Proxy of C++ boost::shared_ptr<(gr_interp_fir_filter_fcc)> class"""
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(self) -> gr_interp_fir_filter_fcc_sptr
        __init__(self,  p) -> gr_interp_fir_filter_fcc_sptr
        """
        this = _gnuradio_core_filter.new_gr_interp_fir_filter_fcc_sptr(*args)
        try: self.this.append(this)
        except: self.this = this
    def __deref__(self):
        """__deref__(self)"""
        return _gnuradio_core_filter.gr_interp_fir_filter_fcc_sptr___deref__(self)

    __swig_destroy__ = _gnuradio_core_filter.delete_gr_interp_fir_filter_fcc_sptr
    __del__ = lambda self : None;
    def set_taps(self, *args, **kwargs):
        """set_taps(self, std::vector<(gr_complex,std::allocator<(gr_complex)>)> taps)"""
        return _gnuradio_core_filter.gr_interp_fir_filter_fcc_sptr_set_taps(self, *args, **kwargs)

    def history(self):
        """history(self) -> unsigned int"""
        return _gnuradio_core_filter.gr_interp_fir_filter_fcc_sptr_history(self)

    def output_multiple(self):
        """output_multiple(self) -> int"""
        return _gnuradio_core_filter.gr_interp_fir_filter_fcc_sptr_output_multiple(self)

    def relative_rate(self):
        """relative_rate(self) -> double"""
        return _gnuradio_core_filter.gr_interp_fir_filter_fcc_sptr_relative_rate(self)

    def start(self):
        """start(self) -> bool"""
        return _gnuradio_core_filter.gr_interp_fir_filter_fcc_sptr_start(self)

    def stop(self):
        """stop(self) -> bool"""
        return _gnuradio_core_filter.gr_interp_fir_filter_fcc_sptr_stop(self)

    def nitems_read(self, *args, **kwargs):
        """nitems_read(self, unsigned int which_input) -> uint64_t"""
        return _gnuradio_core_filter.gr_interp_fir_filter_fcc_sptr_nitems_read(self, *args, **kwargs)

    def nitems_written(self, *args, **kwargs):
        """nitems_written(self, unsigned int which_output) -> uint64_t"""
        return _gnuradio_core_filter.gr_interp_fir_filter_fcc_sptr_nitems_written(self, *args, **kwargs)

    def detail(self):
        """detail(self) -> gr_block_detail_sptr"""
        return _gnuradio_core_filter.gr_interp_fir_filter_fcc_sptr_detail(self)

    def set_detail(self, *args, **kwargs):
        """set_detail(self, gr_block_detail_sptr detail)"""
        return _gnuradio_core_filter.gr_interp_fir_filter_fcc_sptr_set_detail(self, *args, **kwargs)

    def name(self):
        """name(self) -> string"""
        return _gnuradio_core_filter.gr_interp_fir_filter_fcc_sptr_name(self)

    def input_signature(self):
        """input_signature(self) -> gr_io_signature_sptr"""
        return _gnuradio_core_filter.gr_interp_fir_filter_fcc_sptr_input_signature(self)

    def output_signature(self):
        """output_signature(self) -> gr_io_signature_sptr"""
        return _gnuradio_core_filter.gr_interp_fir_filter_fcc_sptr_output_signature(self)

    def unique_id(self):
        """unique_id(self) -> long"""
        return _gnuradio_core_filter.gr_interp_fir_filter_fcc_sptr_unique_id(self)

    def to_basic_block(self):
        """to_basic_block(self) -> gr_basic_block_sptr"""
        return _gnuradio_core_filter.gr_interp_fir_filter_fcc_sptr_to_basic_block(self)

    def check_topology(self, *args, **kwargs):
        """check_topology(self, int ninputs, int noutputs) -> bool"""
        return _gnuradio_core_filter.gr_interp_fir_filter_fcc_sptr_check_topology(self, *args, **kwargs)

gr_interp_fir_filter_fcc_sptr_swigregister = _gnuradio_core_filter.gr_interp_fir_filter_fcc_sptr_swigregister
gr_interp_fir_filter_fcc_sptr_swigregister(gr_interp_fir_filter_fcc_sptr)

gr_interp_fir_filter_fcc_sptr.__repr__ = lambda self: "<gr_block %s (%d)>" % (self.name(), self.unique_id ())


def interp_fir_filter_fcc(*args, **kwargs):
  """
    interp_fir_filter_fcc(int interpolation, std::vector<(gr_complex,std::allocator<(gr_complex)>)> taps) -> gr_interp_fir_filter_fcc_sptr

    Interpolating FIR filter with float input, gr_complex output and gr_complex taps.
    """
  return _gnuradio_core_filter.interp_fir_filter_fcc(*args, **kwargs)
class gr_interp_fir_filter_fff_sptr(object):
    """Proxy of C++ boost::shared_ptr<(gr_interp_fir_filter_fff)> class"""
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(self) -> gr_interp_fir_filter_fff_sptr
        __init__(self,  p) -> gr_interp_fir_filter_fff_sptr
        """
        this = _gnuradio_core_filter.new_gr_interp_fir_filter_fff_sptr(*args)
        try: self.this.append(this)
        except: self.this = this
    def __deref__(self):
        """__deref__(self)"""
        return _gnuradio_core_filter.gr_interp_fir_filter_fff_sptr___deref__(self)

    __swig_destroy__ = _gnuradio_core_filter.delete_gr_interp_fir_filter_fff_sptr
    __del__ = lambda self : None;
    def set_taps(self, *args, **kwargs):
        """set_taps(self, __dummy_4__ taps)"""
        return _gnuradio_core_filter.gr_interp_fir_filter_fff_sptr_set_taps(self, *args, **kwargs)

    def history(self):
        """history(self) -> unsigned int"""
        return _gnuradio_core_filter.gr_interp_fir_filter_fff_sptr_history(self)

    def output_multiple(self):
        """output_multiple(self) -> int"""
        return _gnuradio_core_filter.gr_interp_fir_filter_fff_sptr_output_multiple(self)

    def relative_rate(self):
        """relative_rate(self) -> double"""
        return _gnuradio_core_filter.gr_interp_fir_filter_fff_sptr_relative_rate(self)

    def start(self):
        """start(self) -> bool"""
        return _gnuradio_core_filter.gr_interp_fir_filter_fff_sptr_start(self)

    def stop(self):
        """stop(self) -> bool"""
        return _gnuradio_core_filter.gr_interp_fir_filter_fff_sptr_stop(self)

    def nitems_read(self, *args, **kwargs):
        """nitems_read(self, unsigned int which_input) -> uint64_t"""
        return _gnuradio_core_filter.gr_interp_fir_filter_fff_sptr_nitems_read(self, *args, **kwargs)

    def nitems_written(self, *args, **kwargs):
        """nitems_written(self, unsigned int which_output) -> uint64_t"""
        return _gnuradio_core_filter.gr_interp_fir_filter_fff_sptr_nitems_written(self, *args, **kwargs)

    def detail(self):
        """detail(self) -> gr_block_detail_sptr"""
        return _gnuradio_core_filter.gr_interp_fir_filter_fff_sptr_detail(self)

    def set_detail(self, *args, **kwargs):
        """set_detail(self, gr_block_detail_sptr detail)"""
        return _gnuradio_core_filter.gr_interp_fir_filter_fff_sptr_set_detail(self, *args, **kwargs)

    def name(self):
        """name(self) -> string"""
        return _gnuradio_core_filter.gr_interp_fir_filter_fff_sptr_name(self)

    def input_signature(self):
        """input_signature(self) -> gr_io_signature_sptr"""
        return _gnuradio_core_filter.gr_interp_fir_filter_fff_sptr_input_signature(self)

    def output_signature(self):
        """output_signature(self) -> gr_io_signature_sptr"""
        return _gnuradio_core_filter.gr_interp_fir_filter_fff_sptr_output_signature(self)

    def unique_id(self):
        """unique_id(self) -> long"""
        return _gnuradio_core_filter.gr_interp_fir_filter_fff_sptr_unique_id(self)

    def to_basic_block(self):
        """to_basic_block(self) -> gr_basic_block_sptr"""
        return _gnuradio_core_filter.gr_interp_fir_filter_fff_sptr_to_basic_block(self)

    def check_topology(self, *args, **kwargs):
        """check_topology(self, int ninputs, int noutputs) -> bool"""
        return _gnuradio_core_filter.gr_interp_fir_filter_fff_sptr_check_topology(self, *args, **kwargs)

gr_interp_fir_filter_fff_sptr_swigregister = _gnuradio_core_filter.gr_interp_fir_filter_fff_sptr_swigregister
gr_interp_fir_filter_fff_sptr_swigregister(gr_interp_fir_filter_fff_sptr)

gr_interp_fir_filter_fff_sptr.__repr__ = lambda self: "<gr_block %s (%d)>" % (self.name(), self.unique_id ())


def interp_fir_filter_fff(*args, **kwargs):
  """
    interp_fir_filter_fff(int interpolation, __dummy_4__ taps) -> gr_interp_fir_filter_fff_sptr

    Interpolating FIR filter with float input, float output and float taps.
    """
  return _gnuradio_core_filter.interp_fir_filter_fff(*args, **kwargs)
class gr_interp_fir_filter_fsf_sptr(object):
    """Proxy of C++ boost::shared_ptr<(gr_interp_fir_filter_fsf)> class"""
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(self) -> gr_interp_fir_filter_fsf_sptr
        __init__(self,  p) -> gr_interp_fir_filter_fsf_sptr
        """
        this = _gnuradio_core_filter.new_gr_interp_fir_filter_fsf_sptr(*args)
        try: self.this.append(this)
        except: self.this = this
    def __deref__(self):
        """__deref__(self)"""
        return _gnuradio_core_filter.gr_interp_fir_filter_fsf_sptr___deref__(self)

    __swig_destroy__ = _gnuradio_core_filter.delete_gr_interp_fir_filter_fsf_sptr
    __del__ = lambda self : None;
    def set_taps(self, *args, **kwargs):
        """set_taps(self, __dummy_4__ taps)"""
        return _gnuradio_core_filter.gr_interp_fir_filter_fsf_sptr_set_taps(self, *args, **kwargs)

    def history(self):
        """history(self) -> unsigned int"""
        return _gnuradio_core_filter.gr_interp_fir_filter_fsf_sptr_history(self)

    def output_multiple(self):
        """output_multiple(self) -> int"""
        return _gnuradio_core_filter.gr_interp_fir_filter_fsf_sptr_output_multiple(self)

    def relative_rate(self):
        """relative_rate(self) -> double"""
        return _gnuradio_core_filter.gr_interp_fir_filter_fsf_sptr_relative_rate(self)

    def start(self):
        """start(self) -> bool"""
        return _gnuradio_core_filter.gr_interp_fir_filter_fsf_sptr_start(self)

    def stop(self):
        """stop(self) -> bool"""
        return _gnuradio_core_filter.gr_interp_fir_filter_fsf_sptr_stop(self)

    def nitems_read(self, *args, **kwargs):
        """nitems_read(self, unsigned int which_input) -> uint64_t"""
        return _gnuradio_core_filter.gr_interp_fir_filter_fsf_sptr_nitems_read(self, *args, **kwargs)

    def nitems_written(self, *args, **kwargs):
        """nitems_written(self, unsigned int which_output) -> uint64_t"""
        return _gnuradio_core_filter.gr_interp_fir_filter_fsf_sptr_nitems_written(self, *args, **kwargs)

    def detail(self):
        """detail(self) -> gr_block_detail_sptr"""
        return _gnuradio_core_filter.gr_interp_fir_filter_fsf_sptr_detail(self)

    def set_detail(self, *args, **kwargs):
        """set_detail(self, gr_block_detail_sptr detail)"""
        return _gnuradio_core_filter.gr_interp_fir_filter_fsf_sptr_set_detail(self, *args, **kwargs)

    def name(self):
        """name(self) -> string"""
        return _gnuradio_core_filter.gr_interp_fir_filter_fsf_sptr_name(self)

    def input_signature(self):
        """input_signature(self) -> gr_io_signature_sptr"""
        return _gnuradio_core_filter.gr_interp_fir_filter_fsf_sptr_input_signature(self)

    def output_signature(self):
        """output_signature(self) -> gr_io_signature_sptr"""
        return _gnuradio_core_filter.gr_interp_fir_filter_fsf_sptr_output_signature(self)

    def unique_id(self):
        """unique_id(self) -> long"""
        return _gnuradio_core_filter.gr_interp_fir_filter_fsf_sptr_unique_id(self)

    def to_basic_block(self):
        """to_basic_block(self) -> gr_basic_block_sptr"""
        return _gnuradio_core_filter.gr_interp_fir_filter_fsf_sptr_to_basic_block(self)

    def check_topology(self, *args, **kwargs):
        """check_topology(self, int ninputs, int noutputs) -> bool"""
        return _gnuradio_core_filter.gr_interp_fir_filter_fsf_sptr_check_topology(self, *args, **kwargs)

gr_interp_fir_filter_fsf_sptr_swigregister = _gnuradio_core_filter.gr_interp_fir_filter_fsf_sptr_swigregister
gr_interp_fir_filter_fsf_sptr_swigregister(gr_interp_fir_filter_fsf_sptr)

gr_interp_fir_filter_fsf_sptr.__repr__ = lambda self: "<gr_block %s (%d)>" % (self.name(), self.unique_id ())


def interp_fir_filter_fsf(*args, **kwargs):
  """
    interp_fir_filter_fsf(int interpolation, __dummy_4__ taps) -> gr_interp_fir_filter_fsf_sptr

    Interpolating FIR filter with float input, short output and float taps.
    """
  return _gnuradio_core_filter.interp_fir_filter_fsf(*args, **kwargs)
class gr_interp_fir_filter_scc_sptr(object):
    """Proxy of C++ boost::shared_ptr<(gr_interp_fir_filter_scc)> class"""
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(self) -> gr_interp_fir_filter_scc_sptr
        __init__(self,  p) -> gr_interp_fir_filter_scc_sptr
        """
        this = _gnuradio_core_filter.new_gr_interp_fir_filter_scc_sptr(*args)
        try: self.this.append(this)
        except: self.this = this
    def __deref__(self):
        """__deref__(self)"""
        return _gnuradio_core_filter.gr_interp_fir_filter_scc_sptr___deref__(self)

    __swig_destroy__ = _gnuradio_core_filter.delete_gr_interp_fir_filter_scc_sptr
    __del__ = lambda self : None;
    def set_taps(self, *args, **kwargs):
        """set_taps(self, std::vector<(gr_complex,std::allocator<(gr_complex)>)> taps)"""
        return _gnuradio_core_filter.gr_interp_fir_filter_scc_sptr_set_taps(self, *args, **kwargs)

    def history(self):
        """history(self) -> unsigned int"""
        return _gnuradio_core_filter.gr_interp_fir_filter_scc_sptr_history(self)

    def output_multiple(self):
        """output_multiple(self) -> int"""
        return _gnuradio_core_filter.gr_interp_fir_filter_scc_sptr_output_multiple(self)

    def relative_rate(self):
        """relative_rate(self) -> double"""
        return _gnuradio_core_filter.gr_interp_fir_filter_scc_sptr_relative_rate(self)

    def start(self):
        """start(self) -> bool"""
        return _gnuradio_core_filter.gr_interp_fir_filter_scc_sptr_start(self)

    def stop(self):
        """stop(self) -> bool"""
        return _gnuradio_core_filter.gr_interp_fir_filter_scc_sptr_stop(self)

    def nitems_read(self, *args, **kwargs):
        """nitems_read(self, unsigned int which_input) -> uint64_t"""
        return _gnuradio_core_filter.gr_interp_fir_filter_scc_sptr_nitems_read(self, *args, **kwargs)

    def nitems_written(self, *args, **kwargs):
        """nitems_written(self, unsigned int which_output) -> uint64_t"""
        return _gnuradio_core_filter.gr_interp_fir_filter_scc_sptr_nitems_written(self, *args, **kwargs)

    def detail(self):
        """detail(self) -> gr_block_detail_sptr"""
        return _gnuradio_core_filter.gr_interp_fir_filter_scc_sptr_detail(self)

    def set_detail(self, *args, **kwargs):
        """set_detail(self, gr_block_detail_sptr detail)"""
        return _gnuradio_core_filter.gr_interp_fir_filter_scc_sptr_set_detail(self, *args, **kwargs)

    def name(self):
        """name(self) -> string"""
        return _gnuradio_core_filter.gr_interp_fir_filter_scc_sptr_name(self)

    def input_signature(self):
        """input_signature(self) -> gr_io_signature_sptr"""
        return _gnuradio_core_filter.gr_interp_fir_filter_scc_sptr_input_signature(self)

    def output_signature(self):
        """output_signature(self) -> gr_io_signature_sptr"""
        return _gnuradio_core_filter.gr_interp_fir_filter_scc_sptr_output_signature(self)

    def unique_id(self):
        """unique_id(self) -> long"""
        return _gnuradio_core_filter.gr_interp_fir_filter_scc_sptr_unique_id(self)

    def to_basic_block(self):
        """to_basic_block(self) -> gr_basic_block_sptr"""
        return _gnuradio_core_filter.gr_interp_fir_filter_scc_sptr_to_basic_block(self)

    def check_topology(self, *args, **kwargs):
        """check_topology(self, int ninputs, int noutputs) -> bool"""
        return _gnuradio_core_filter.gr_interp_fir_filter_scc_sptr_check_topology(self, *args, **kwargs)

gr_interp_fir_filter_scc_sptr_swigregister = _gnuradio_core_filter.gr_interp_fir_filter_scc_sptr_swigregister
gr_interp_fir_filter_scc_sptr_swigregister(gr_interp_fir_filter_scc_sptr)

gr_interp_fir_filter_scc_sptr.__repr__ = lambda self: "<gr_block %s (%d)>" % (self.name(), self.unique_id ())


def interp_fir_filter_scc(*args, **kwargs):
  """
    interp_fir_filter_scc(int interpolation, std::vector<(gr_complex,std::allocator<(gr_complex)>)> taps) -> gr_interp_fir_filter_scc_sptr

    Interpolating FIR filter with short input, gr_complex output and gr_complex taps.
    """
  return _gnuradio_core_filter.interp_fir_filter_scc(*args, **kwargs)
class gr_rational_resampler_base_ccc_sptr(object):
    """Proxy of C++ boost::shared_ptr<(gr_rational_resampler_base_ccc)> class"""
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(self) -> gr_rational_resampler_base_ccc_sptr
        __init__(self,  p) -> gr_rational_resampler_base_ccc_sptr
        """
        this = _gnuradio_core_filter.new_gr_rational_resampler_base_ccc_sptr(*args)
        try: self.this.append(this)
        except: self.this = this
    def __deref__(self):
        """__deref__(self)"""
        return _gnuradio_core_filter.gr_rational_resampler_base_ccc_sptr___deref__(self)

    __swig_destroy__ = _gnuradio_core_filter.delete_gr_rational_resampler_base_ccc_sptr
    __del__ = lambda self : None;
    def set_taps(self, *args, **kwargs):
        """set_taps(self, std::vector<(gr_complex,std::allocator<(gr_complex)>)> taps)"""
        return _gnuradio_core_filter.gr_rational_resampler_base_ccc_sptr_set_taps(self, *args, **kwargs)

    def history(self):
        """history(self) -> unsigned int"""
        return _gnuradio_core_filter.gr_rational_resampler_base_ccc_sptr_history(self)

    def output_multiple(self):
        """output_multiple(self) -> int"""
        return _gnuradio_core_filter.gr_rational_resampler_base_ccc_sptr_output_multiple(self)

    def relative_rate(self):
        """relative_rate(self) -> double"""
        return _gnuradio_core_filter.gr_rational_resampler_base_ccc_sptr_relative_rate(self)

    def start(self):
        """start(self) -> bool"""
        return _gnuradio_core_filter.gr_rational_resampler_base_ccc_sptr_start(self)

    def stop(self):
        """stop(self) -> bool"""
        return _gnuradio_core_filter.gr_rational_resampler_base_ccc_sptr_stop(self)

    def nitems_read(self, *args, **kwargs):
        """nitems_read(self, unsigned int which_input) -> uint64_t"""
        return _gnuradio_core_filter.gr_rational_resampler_base_ccc_sptr_nitems_read(self, *args, **kwargs)

    def nitems_written(self, *args, **kwargs):
        """nitems_written(self, unsigned int which_output) -> uint64_t"""
        return _gnuradio_core_filter.gr_rational_resampler_base_ccc_sptr_nitems_written(self, *args, **kwargs)

    def detail(self):
        """detail(self) -> gr_block_detail_sptr"""
        return _gnuradio_core_filter.gr_rational_resampler_base_ccc_sptr_detail(self)

    def set_detail(self, *args, **kwargs):
        """set_detail(self, gr_block_detail_sptr detail)"""
        return _gnuradio_core_filter.gr_rational_resampler_base_ccc_sptr_set_detail(self, *args, **kwargs)

    def name(self):
        """name(self) -> string"""
        return _gnuradio_core_filter.gr_rational_resampler_base_ccc_sptr_name(self)

    def input_signature(self):
        """input_signature(self) -> gr_io_signature_sptr"""
        return _gnuradio_core_filter.gr_rational_resampler_base_ccc_sptr_input_signature(self)

    def output_signature(self):
        """output_signature(self) -> gr_io_signature_sptr"""
        return _gnuradio_core_filter.gr_rational_resampler_base_ccc_sptr_output_signature(self)

    def unique_id(self):
        """unique_id(self) -> long"""
        return _gnuradio_core_filter.gr_rational_resampler_base_ccc_sptr_unique_id(self)

    def to_basic_block(self):
        """to_basic_block(self) -> gr_basic_block_sptr"""
        return _gnuradio_core_filter.gr_rational_resampler_base_ccc_sptr_to_basic_block(self)

    def check_topology(self, *args, **kwargs):
        """check_topology(self, int ninputs, int noutputs) -> bool"""
        return _gnuradio_core_filter.gr_rational_resampler_base_ccc_sptr_check_topology(self, *args, **kwargs)

gr_rational_resampler_base_ccc_sptr_swigregister = _gnuradio_core_filter.gr_rational_resampler_base_ccc_sptr_swigregister
gr_rational_resampler_base_ccc_sptr_swigregister(gr_rational_resampler_base_ccc_sptr)

gr_rational_resampler_base_ccc_sptr.__repr__ = lambda self: "<gr_block %s (%d)>" % (self.name(), self.unique_id ())


def rational_resampler_base_ccc(*args, **kwargs):
  """
    rational_resampler_base_ccc(int interpolation, int decimation, std::vector<(gr_complex,std::allocator<(gr_complex)>)> taps) -> gr_rational_resampler_base_ccc_sptr

    Rational Resampling Polyphase FIR filter with gr_complex input, gr_complex output and gr_complex taps.
    """
  return _gnuradio_core_filter.rational_resampler_base_ccc(*args, **kwargs)
class gr_rational_resampler_base_ccf_sptr(object):
    """Proxy of C++ boost::shared_ptr<(gr_rational_resampler_base_ccf)> class"""
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(self) -> gr_rational_resampler_base_ccf_sptr
        __init__(self,  p) -> gr_rational_resampler_base_ccf_sptr
        """
        this = _gnuradio_core_filter.new_gr_rational_resampler_base_ccf_sptr(*args)
        try: self.this.append(this)
        except: self.this = this
    def __deref__(self):
        """__deref__(self)"""
        return _gnuradio_core_filter.gr_rational_resampler_base_ccf_sptr___deref__(self)

    __swig_destroy__ = _gnuradio_core_filter.delete_gr_rational_resampler_base_ccf_sptr
    __del__ = lambda self : None;
    def set_taps(self, *args, **kwargs):
        """set_taps(self, __dummy_4__ taps)"""
        return _gnuradio_core_filter.gr_rational_resampler_base_ccf_sptr_set_taps(self, *args, **kwargs)

    def history(self):
        """history(self) -> unsigned int"""
        return _gnuradio_core_filter.gr_rational_resampler_base_ccf_sptr_history(self)

    def output_multiple(self):
        """output_multiple(self) -> int"""
        return _gnuradio_core_filter.gr_rational_resampler_base_ccf_sptr_output_multiple(self)

    def relative_rate(self):
        """relative_rate(self) -> double"""
        return _gnuradio_core_filter.gr_rational_resampler_base_ccf_sptr_relative_rate(self)

    def start(self):
        """start(self) -> bool"""
        return _gnuradio_core_filter.gr_rational_resampler_base_ccf_sptr_start(self)

    def stop(self):
        """stop(self) -> bool"""
        return _gnuradio_core_filter.gr_rational_resampler_base_ccf_sptr_stop(self)

    def nitems_read(self, *args, **kwargs):
        """nitems_read(self, unsigned int which_input) -> uint64_t"""
        return _gnuradio_core_filter.gr_rational_resampler_base_ccf_sptr_nitems_read(self, *args, **kwargs)

    def nitems_written(self, *args, **kwargs):
        """nitems_written(self, unsigned int which_output) -> uint64_t"""
        return _gnuradio_core_filter.gr_rational_resampler_base_ccf_sptr_nitems_written(self, *args, **kwargs)

    def detail(self):
        """detail(self) -> gr_block_detail_sptr"""
        return _gnuradio_core_filter.gr_rational_resampler_base_ccf_sptr_detail(self)

    def set_detail(self, *args, **kwargs):
        """set_detail(self, gr_block_detail_sptr detail)"""
        return _gnuradio_core_filter.gr_rational_resampler_base_ccf_sptr_set_detail(self, *args, **kwargs)

    def name(self):
        """name(self) -> string"""
        return _gnuradio_core_filter.gr_rational_resampler_base_ccf_sptr_name(self)

    def input_signature(self):
        """input_signature(self) -> gr_io_signature_sptr"""
        return _gnuradio_core_filter.gr_rational_resampler_base_ccf_sptr_input_signature(self)

    def output_signature(self):
        """output_signature(self) -> gr_io_signature_sptr"""
        return _gnuradio_core_filter.gr_rational_resampler_base_ccf_sptr_output_signature(self)

    def unique_id(self):
        """unique_id(self) -> long"""
        return _gnuradio_core_filter.gr_rational_resampler_base_ccf_sptr_unique_id(self)

    def to_basic_block(self):
        """to_basic_block(self) -> gr_basic_block_sptr"""
        return _gnuradio_core_filter.gr_rational_resampler_base_ccf_sptr_to_basic_block(self)

    def check_topology(self, *args, **kwargs):
        """check_topology(self, int ninputs, int noutputs) -> bool"""
        return _gnuradio_core_filter.gr_rational_resampler_base_ccf_sptr_check_topology(self, *args, **kwargs)

gr_rational_resampler_base_ccf_sptr_swigregister = _gnuradio_core_filter.gr_rational_resampler_base_ccf_sptr_swigregister
gr_rational_resampler_base_ccf_sptr_swigregister(gr_rational_resampler_base_ccf_sptr)

gr_rational_resampler_base_ccf_sptr.__repr__ = lambda self: "<gr_block %s (%d)>" % (self.name(), self.unique_id ())


def rational_resampler_base_ccf(*args, **kwargs):
  """
    rational_resampler_base_ccf(int interpolation, int decimation, __dummy_4__ taps) -> gr_rational_resampler_base_ccf_sptr

    Rational Resampling Polyphase FIR filter with gr_complex input, gr_complex output and float taps.
    """
  return _gnuradio_core_filter.rational_resampler_base_ccf(*args, **kwargs)
class gr_rational_resampler_base_fcc_sptr(object):
    """Proxy of C++ boost::shared_ptr<(gr_rational_resampler_base_fcc)> class"""
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(self) -> gr_rational_resampler_base_fcc_sptr
        __init__(self,  p) -> gr_rational_resampler_base_fcc_sptr
        """
        this = _gnuradio_core_filter.new_gr_rational_resampler_base_fcc_sptr(*args)
        try: self.this.append(this)
        except: self.this = this
    def __deref__(self):
        """__deref__(self)"""
        return _gnuradio_core_filter.gr_rational_resampler_base_fcc_sptr___deref__(self)

    __swig_destroy__ = _gnuradio_core_filter.delete_gr_rational_resampler_base_fcc_sptr
    __del__ = lambda self : None;
    def set_taps(self, *args, **kwargs):
        """set_taps(self, std::vector<(gr_complex,std::allocator<(gr_complex)>)> taps)"""
        return _gnuradio_core_filter.gr_rational_resampler_base_fcc_sptr_set_taps(self, *args, **kwargs)

    def history(self):
        """history(self) -> unsigned int"""
        return _gnuradio_core_filter.gr_rational_resampler_base_fcc_sptr_history(self)

    def output_multiple(self):
        """output_multiple(self) -> int"""
        return _gnuradio_core_filter.gr_rational_resampler_base_fcc_sptr_output_multiple(self)

    def relative_rate(self):
        """relative_rate(self) -> double"""
        return _gnuradio_core_filter.gr_rational_resampler_base_fcc_sptr_relative_rate(self)

    def start(self):
        """start(self) -> bool"""
        return _gnuradio_core_filter.gr_rational_resampler_base_fcc_sptr_start(self)

    def stop(self):
        """stop(self) -> bool"""
        return _gnuradio_core_filter.gr_rational_resampler_base_fcc_sptr_stop(self)

    def nitems_read(self, *args, **kwargs):
        """nitems_read(self, unsigned int which_input) -> uint64_t"""
        return _gnuradio_core_filter.gr_rational_resampler_base_fcc_sptr_nitems_read(self, *args, **kwargs)

    def nitems_written(self, *args, **kwargs):
        """nitems_written(self, unsigned int which_output) -> uint64_t"""
        return _gnuradio_core_filter.gr_rational_resampler_base_fcc_sptr_nitems_written(self, *args, **kwargs)

    def detail(self):
        """detail(self) -> gr_block_detail_sptr"""
        return _gnuradio_core_filter.gr_rational_resampler_base_fcc_sptr_detail(self)

    def set_detail(self, *args, **kwargs):
        """set_detail(self, gr_block_detail_sptr detail)"""
        return _gnuradio_core_filter.gr_rational_resampler_base_fcc_sptr_set_detail(self, *args, **kwargs)

    def name(self):
        """name(self) -> string"""
        return _gnuradio_core_filter.gr_rational_resampler_base_fcc_sptr_name(self)

    def input_signature(self):
        """input_signature(self) -> gr_io_signature_sptr"""
        return _gnuradio_core_filter.gr_rational_resampler_base_fcc_sptr_input_signature(self)

    def output_signature(self):
        """output_signature(self) -> gr_io_signature_sptr"""
        return _gnuradio_core_filter.gr_rational_resampler_base_fcc_sptr_output_signature(self)

    def unique_id(self):
        """unique_id(self) -> long"""
        return _gnuradio_core_filter.gr_rational_resampler_base_fcc_sptr_unique_id(self)

    def to_basic_block(self):
        """to_basic_block(self) -> gr_basic_block_sptr"""
        return _gnuradio_core_filter.gr_rational_resampler_base_fcc_sptr_to_basic_block(self)

    def check_topology(self, *args, **kwargs):
        """check_topology(self, int ninputs, int noutputs) -> bool"""
        return _gnuradio_core_filter.gr_rational_resampler_base_fcc_sptr_check_topology(self, *args, **kwargs)

gr_rational_resampler_base_fcc_sptr_swigregister = _gnuradio_core_filter.gr_rational_resampler_base_fcc_sptr_swigregister
gr_rational_resampler_base_fcc_sptr_swigregister(gr_rational_resampler_base_fcc_sptr)

gr_rational_resampler_base_fcc_sptr.__repr__ = lambda self: "<gr_block %s (%d)>" % (self.name(), self.unique_id ())


def rational_resampler_base_fcc(*args, **kwargs):
  """
    rational_resampler_base_fcc(int interpolation, int decimation, std::vector<(gr_complex,std::allocator<(gr_complex)>)> taps) -> gr_rational_resampler_base_fcc_sptr

    Rational Resampling Polyphase FIR filter with float input, gr_complex output and gr_complex taps.
    """
  return _gnuradio_core_filter.rational_resampler_base_fcc(*args, **kwargs)
class gr_rational_resampler_base_fff_sptr(object):
    """Proxy of C++ boost::shared_ptr<(gr_rational_resampler_base_fff)> class"""
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(self) -> gr_rational_resampler_base_fff_sptr
        __init__(self,  p) -> gr_rational_resampler_base_fff_sptr
        """
        this = _gnuradio_core_filter.new_gr_rational_resampler_base_fff_sptr(*args)
        try: self.this.append(this)
        except: self.this = this
    def __deref__(self):
        """__deref__(self)"""
        return _gnuradio_core_filter.gr_rational_resampler_base_fff_sptr___deref__(self)

    __swig_destroy__ = _gnuradio_core_filter.delete_gr_rational_resampler_base_fff_sptr
    __del__ = lambda self : None;
    def set_taps(self, *args, **kwargs):
        """set_taps(self, __dummy_4__ taps)"""
        return _gnuradio_core_filter.gr_rational_resampler_base_fff_sptr_set_taps(self, *args, **kwargs)

    def history(self):
        """history(self) -> unsigned int"""
        return _gnuradio_core_filter.gr_rational_resampler_base_fff_sptr_history(self)

    def output_multiple(self):
        """output_multiple(self) -> int"""
        return _gnuradio_core_filter.gr_rational_resampler_base_fff_sptr_output_multiple(self)

    def relative_rate(self):
        """relative_rate(self) -> double"""
        return _gnuradio_core_filter.gr_rational_resampler_base_fff_sptr_relative_rate(self)

    def start(self):
        """start(self) -> bool"""
        return _gnuradio_core_filter.gr_rational_resampler_base_fff_sptr_start(self)

    def stop(self):
        """stop(self) -> bool"""
        return _gnuradio_core_filter.gr_rational_resampler_base_fff_sptr_stop(self)

    def nitems_read(self, *args, **kwargs):
        """nitems_read(self, unsigned int which_input) -> uint64_t"""
        return _gnuradio_core_filter.gr_rational_resampler_base_fff_sptr_nitems_read(self, *args, **kwargs)

    def nitems_written(self, *args, **kwargs):
        """nitems_written(self, unsigned int which_output) -> uint64_t"""
        return _gnuradio_core_filter.gr_rational_resampler_base_fff_sptr_nitems_written(self, *args, **kwargs)

    def detail(self):
        """detail(self) -> gr_block_detail_sptr"""
        return _gnuradio_core_filter.gr_rational_resampler_base_fff_sptr_detail(self)

    def set_detail(self, *args, **kwargs):
        """set_detail(self, gr_block_detail_sptr detail)"""
        return _gnuradio_core_filter.gr_rational_resampler_base_fff_sptr_set_detail(self, *args, **kwargs)

    def name(self):
        """name(self) -> string"""
        return _gnuradio_core_filter.gr_rational_resampler_base_fff_sptr_name(self)

    def input_signature(self):
        """input_signature(self) -> gr_io_signature_sptr"""
        return _gnuradio_core_filter.gr_rational_resampler_base_fff_sptr_input_signature(self)

    def output_signature(self):
        """output_signature(self) -> gr_io_signature_sptr"""
        return _gnuradio_core_filter.gr_rational_resampler_base_fff_sptr_output_signature(self)

    def unique_id(self):
        """unique_id(self) -> long"""
        return _gnuradio_core_filter.gr_rational_resampler_base_fff_sptr_unique_id(self)

    def to_basic_block(self):
        """to_basic_block(self) -> gr_basic_block_sptr"""
        return _gnuradio_core_filter.gr_rational_resampler_base_fff_sptr_to_basic_block(self)

    def check_topology(self, *args, **kwargs):
        """check_topology(self, int ninputs, int noutputs) -> bool"""
        return _gnuradio_core_filter.gr_rational_resampler_base_fff_sptr_check_topology(self, *args, **kwargs)

gr_rational_resampler_base_fff_sptr_swigregister = _gnuradio_core_filter.gr_rational_resampler_base_fff_sptr_swigregister
gr_rational_resampler_base_fff_sptr_swigregister(gr_rational_resampler_base_fff_sptr)

gr_rational_resampler_base_fff_sptr.__repr__ = lambda self: "<gr_block %s (%d)>" % (self.name(), self.unique_id ())


def rational_resampler_base_fff(*args, **kwargs):
  """
    rational_resampler_base_fff(int interpolation, int decimation, __dummy_4__ taps) -> gr_rational_resampler_base_fff_sptr

    Rational Resampling Polyphase FIR filter with float input, float output and float taps.
    """
  return _gnuradio_core_filter.rational_resampler_base_fff(*args, **kwargs)
class gr_rational_resampler_base_fsf_sptr(object):
    """Proxy of C++ boost::shared_ptr<(gr_rational_resampler_base_fsf)> class"""
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(self) -> gr_rational_resampler_base_fsf_sptr
        __init__(self,  p) -> gr_rational_resampler_base_fsf_sptr
        """
        this = _gnuradio_core_filter.new_gr_rational_resampler_base_fsf_sptr(*args)
        try: self.this.append(this)
        except: self.this = this
    def __deref__(self):
        """__deref__(self)"""
        return _gnuradio_core_filter.gr_rational_resampler_base_fsf_sptr___deref__(self)

    __swig_destroy__ = _gnuradio_core_filter.delete_gr_rational_resampler_base_fsf_sptr
    __del__ = lambda self : None;
    def set_taps(self, *args, **kwargs):
        """set_taps(self, __dummy_4__ taps)"""
        return _gnuradio_core_filter.gr_rational_resampler_base_fsf_sptr_set_taps(self, *args, **kwargs)

    def history(self):
        """history(self) -> unsigned int"""
        return _gnuradio_core_filter.gr_rational_resampler_base_fsf_sptr_history(self)

    def output_multiple(self):
        """output_multiple(self) -> int"""
        return _gnuradio_core_filter.gr_rational_resampler_base_fsf_sptr_output_multiple(self)

    def relative_rate(self):
        """relative_rate(self) -> double"""
        return _gnuradio_core_filter.gr_rational_resampler_base_fsf_sptr_relative_rate(self)

    def start(self):
        """start(self) -> bool"""
        return _gnuradio_core_filter.gr_rational_resampler_base_fsf_sptr_start(self)

    def stop(self):
        """stop(self) -> bool"""
        return _gnuradio_core_filter.gr_rational_resampler_base_fsf_sptr_stop(self)

    def nitems_read(self, *args, **kwargs):
        """nitems_read(self, unsigned int which_input) -> uint64_t"""
        return _gnuradio_core_filter.gr_rational_resampler_base_fsf_sptr_nitems_read(self, *args, **kwargs)

    def nitems_written(self, *args, **kwargs):
        """nitems_written(self, unsigned int which_output) -> uint64_t"""
        return _gnuradio_core_filter.gr_rational_resampler_base_fsf_sptr_nitems_written(self, *args, **kwargs)

    def detail(self):
        """detail(self) -> gr_block_detail_sptr"""
        return _gnuradio_core_filter.gr_rational_resampler_base_fsf_sptr_detail(self)

    def set_detail(self, *args, **kwargs):
        """set_detail(self, gr_block_detail_sptr detail)"""
        return _gnuradio_core_filter.gr_rational_resampler_base_fsf_sptr_set_detail(self, *args, **kwargs)

    def name(self):
        """name(self) -> string"""
        return _gnuradio_core_filter.gr_rational_resampler_base_fsf_sptr_name(self)

    def input_signature(self):
        """input_signature(self) -> gr_io_signature_sptr"""
        return _gnuradio_core_filter.gr_rational_resampler_base_fsf_sptr_input_signature(self)

    def output_signature(self):
        """output_signature(self) -> gr_io_signature_sptr"""
        return _gnuradio_core_filter.gr_rational_resampler_base_fsf_sptr_output_signature(self)

    def unique_id(self):
        """unique_id(self) -> long"""
        return _gnuradio_core_filter.gr_rational_resampler_base_fsf_sptr_unique_id(self)

    def to_basic_block(self):
        """to_basic_block(self) -> gr_basic_block_sptr"""
        return _gnuradio_core_filter.gr_rational_resampler_base_fsf_sptr_to_basic_block(self)

    def check_topology(self, *args, **kwargs):
        """check_topology(self, int ninputs, int noutputs) -> bool"""
        return _gnuradio_core_filter.gr_rational_resampler_base_fsf_sptr_check_topology(self, *args, **kwargs)

gr_rational_resampler_base_fsf_sptr_swigregister = _gnuradio_core_filter.gr_rational_resampler_base_fsf_sptr_swigregister
gr_rational_resampler_base_fsf_sptr_swigregister(gr_rational_resampler_base_fsf_sptr)

gr_rational_resampler_base_fsf_sptr.__repr__ = lambda self: "<gr_block %s (%d)>" % (self.name(), self.unique_id ())


def rational_resampler_base_fsf(*args, **kwargs):
  """
    rational_resampler_base_fsf(int interpolation, int decimation, __dummy_4__ taps) -> gr_rational_resampler_base_fsf_sptr

    Rational Resampling Polyphase FIR filter with float input, short output and float taps.
    """
  return _gnuradio_core_filter.rational_resampler_base_fsf(*args, **kwargs)
class gr_rational_resampler_base_scc_sptr(object):
    """Proxy of C++ boost::shared_ptr<(gr_rational_resampler_base_scc)> class"""
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(self) -> gr_rational_resampler_base_scc_sptr
        __init__(self,  p) -> gr_rational_resampler_base_scc_sptr
        """
        this = _gnuradio_core_filter.new_gr_rational_resampler_base_scc_sptr(*args)
        try: self.this.append(this)
        except: self.this = this
    def __deref__(self):
        """__deref__(self)"""
        return _gnuradio_core_filter.gr_rational_resampler_base_scc_sptr___deref__(self)

    __swig_destroy__ = _gnuradio_core_filter.delete_gr_rational_resampler_base_scc_sptr
    __del__ = lambda self : None;
    def set_taps(self, *args, **kwargs):
        """set_taps(self, std::vector<(gr_complex,std::allocator<(gr_complex)>)> taps)"""
        return _gnuradio_core_filter.gr_rational_resampler_base_scc_sptr_set_taps(self, *args, **kwargs)

    def history(self):
        """history(self) -> unsigned int"""
        return _gnuradio_core_filter.gr_rational_resampler_base_scc_sptr_history(self)

    def output_multiple(self):
        """output_multiple(self) -> int"""
        return _gnuradio_core_filter.gr_rational_resampler_base_scc_sptr_output_multiple(self)

    def relative_rate(self):
        """relative_rate(self) -> double"""
        return _gnuradio_core_filter.gr_rational_resampler_base_scc_sptr_relative_rate(self)

    def start(self):
        """start(self) -> bool"""
        return _gnuradio_core_filter.gr_rational_resampler_base_scc_sptr_start(self)

    def stop(self):
        """stop(self) -> bool"""
        return _gnuradio_core_filter.gr_rational_resampler_base_scc_sptr_stop(self)

    def nitems_read(self, *args, **kwargs):
        """nitems_read(self, unsigned int which_input) -> uint64_t"""
        return _gnuradio_core_filter.gr_rational_resampler_base_scc_sptr_nitems_read(self, *args, **kwargs)

    def nitems_written(self, *args, **kwargs):
        """nitems_written(self, unsigned int which_output) -> uint64_t"""
        return _gnuradio_core_filter.gr_rational_resampler_base_scc_sptr_nitems_written(self, *args, **kwargs)

    def detail(self):
        """detail(self) -> gr_block_detail_sptr"""
        return _gnuradio_core_filter.gr_rational_resampler_base_scc_sptr_detail(self)

    def set_detail(self, *args, **kwargs):
        """set_detail(self, gr_block_detail_sptr detail)"""
        return _gnuradio_core_filter.gr_rational_resampler_base_scc_sptr_set_detail(self, *args, **kwargs)

    def name(self):
        """name(self) -> string"""
        return _gnuradio_core_filter.gr_rational_resampler_base_scc_sptr_name(self)

    def input_signature(self):
        """input_signature(self) -> gr_io_signature_sptr"""
        return _gnuradio_core_filter.gr_rational_resampler_base_scc_sptr_input_signature(self)

    def output_signature(self):
        """output_signature(self) -> gr_io_signature_sptr"""
        return _gnuradio_core_filter.gr_rational_resampler_base_scc_sptr_output_signature(self)

    def unique_id(self):
        """unique_id(self) -> long"""
        return _gnuradio_core_filter.gr_rational_resampler_base_scc_sptr_unique_id(self)

    def to_basic_block(self):
        """to_basic_block(self) -> gr_basic_block_sptr"""
        return _gnuradio_core_filter.gr_rational_resampler_base_scc_sptr_to_basic_block(self)

    def check_topology(self, *args, **kwargs):
        """check_topology(self, int ninputs, int noutputs) -> bool"""
        return _gnuradio_core_filter.gr_rational_resampler_base_scc_sptr_check_topology(self, *args, **kwargs)

gr_rational_resampler_base_scc_sptr_swigregister = _gnuradio_core_filter.gr_rational_resampler_base_scc_sptr_swigregister
gr_rational_resampler_base_scc_sptr_swigregister(gr_rational_resampler_base_scc_sptr)

gr_rational_resampler_base_scc_sptr.__repr__ = lambda self: "<gr_block %s (%d)>" % (self.name(), self.unique_id ())


def rational_resampler_base_scc(*args, **kwargs):
  """
    rational_resampler_base_scc(int interpolation, int decimation, std::vector<(gr_complex,std::allocator<(gr_complex)>)> taps) -> gr_rational_resampler_base_scc_sptr

    Rational Resampling Polyphase FIR filter with short input, gr_complex output and gr_complex taps.
    """
  return _gnuradio_core_filter.rational_resampler_base_scc(*args, **kwargs)


